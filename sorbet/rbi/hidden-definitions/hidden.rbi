# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module ActiveSupport
  def parse_json_times(); end

  def parse_json_times=(val); end
end

class ActiveSupport::ArrayInquirer
  def any?(*candidates); end
end

class ActiveSupport::ArrayInquirer
end

class ActiveSupport::BacktraceCleaner
  def add_filter(&block); end

  def add_silencer(&block); end

  def clean_frame(frame, kind=T.unsafe(nil)); end

  def filter(backtrace, kind=T.unsafe(nil)); end

  def remove_filters!(); end

  def remove_silencers!(); end
  FORMATTED_GEMS_PATTERN = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Benchmarkable
  def benchmark(message=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

module ActiveSupport::Benchmarkable
end

module ActiveSupport::BigDecimalWithDefaultFormat
  def to_s(format=T.unsafe(nil)); end
end

module ActiveSupport::BigDecimalWithDefaultFormat
end

module ActiveSupport::Cache
  DEFAULT_COMPRESS_LIMIT = ::T.let(nil, ::T.untyped)
  OPTION_ALIASES = ::T.let(nil, ::T.untyped)
  UNIVERSAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Coder
  def dump(entry); end

  def dump_compressed(entry, threshold); end

  def initialize(serializer, compressor, legacy_serializer: T.unsafe(nil)); end

  def load(dumped); end
  COMPRESSED_FLAG = ::T.let(nil, ::T.untyped)
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
  OBJECT_DUMP_TYPE = ::T.let(nil, ::T.untyped)
  PACKED_EXPIRES_AT_TEMPLATE = ::T.let(nil, ::T.untyped)
  PACKED_TEMPLATE = ::T.let(nil, ::T.untyped)
  PACKED_TYPE_TEMPLATE = ::T.let(nil, ::T.untyped)
  PACKED_VERSION_INDEX = ::T.let(nil, ::T.untyped)
  PACKED_VERSION_LENGTH_TEMPLATE = ::T.let(nil, ::T.untyped)
  SIGNATURE = ::T.let(nil, ::T.untyped)
  STRING_DESERIALIZERS = ::T.let(nil, ::T.untyped)
  STRING_ENCODINGS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Coder::LazyEntry
  def initialize(serializer, compressor, payload, **options); end
end

class ActiveSupport::Cache::Coder::LazyEntry
end

class ActiveSupport::Cache::Coder::StringDeserializer
  def initialize(encoding); end

  def load(payload); end
end

class ActiveSupport::Cache::Coder::StringDeserializer
end

class ActiveSupport::Cache::Coder
end

class ActiveSupport::Cache::DeserializationError
end

class ActiveSupport::Cache::DeserializationError
end

class ActiveSupport::Cache::Entry
  def bytesize(); end

  def compressed(compress_threshold); end

  def compressed?(); end

  def dup_value!(); end

  def expired?(); end

  def expires_at(); end

  def expires_at=(value); end

  def initialize(value, compressed: T.unsafe(nil), version: T.unsafe(nil), expires_in: T.unsafe(nil), expires_at: T.unsafe(nil), **arg); end

  def local?(); end

  def mismatched?(version); end

  def pack(); end

  def value(); end

  def version(); end
end

class ActiveSupport::Cache::Entry
  def self.unpack(members); end
end

class ActiveSupport::Cache::FileStore
  def cache_path(); end

  def initialize(cache_path, **options); end
end

class ActiveSupport::Cache::FileStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::MemoryStore
  def prune(target_size, max_time=T.unsafe(nil)); end

  def pruning?(); end

  def synchronize(&block); end
end

module ActiveSupport::Cache::MemoryStore::DupCoder
  def dump(entry); end

  def dump_compressed(entry, threshold); end

  def load(entry); end
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::MemoryStore::DupCoder
  extend ::ActiveSupport::Cache::MemoryStore::DupCoder
end

class ActiveSupport::Cache::MemoryStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::NullStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
end

class ActiveSupport::Cache::NullStore
  def self.supports_cache_versioning?(); end
end

module ActiveSupport::Cache::SerializerWithFallback
  def load(dumped); end
  SERIALIZERS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::SerializerWithFallback::Marshal70WithFallback
  include ::ActiveSupport::Cache::SerializerWithFallback
  def _load(marked); end

  def dump(entry); end

  def dump_compressed(entry, threshold); end

  def dumped?(dumped); end
  MARK_COMPRESSED = ::T.let(nil, ::T.untyped)
  MARK_UNCOMPRESSED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::SerializerWithFallback::Marshal70WithFallback
  extend ::ActiveSupport::Cache::SerializerWithFallback::Marshal70WithFallback
  extend ::ActiveSupport::Cache::SerializerWithFallback
end

module ActiveSupport::Cache::SerializerWithFallback::Marshal71WithFallback
  include ::ActiveSupport::Cache::SerializerWithFallback
  def _load(dumped); end

  def dump(value); end

  def dumped?(dumped); end
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::SerializerWithFallback::Marshal71WithFallback
  extend ::ActiveSupport::Cache::SerializerWithFallback::Marshal71WithFallback
  extend ::ActiveSupport::Cache::SerializerWithFallback
end

module ActiveSupport::Cache::SerializerWithFallback::MessagePackWithFallback
  include ::ActiveSupport::Cache::SerializerWithFallback
  def _load(dumped); end

  def dump(value); end

  def dumped?(dumped); end
end

module ActiveSupport::Cache::SerializerWithFallback::MessagePackWithFallback
  extend ::ActiveSupport::Cache::SerializerWithFallback::MessagePackWithFallback
  extend ::ActiveSupport::Cache::SerializerWithFallback
end

module ActiveSupport::Cache::SerializerWithFallback::PassthroughWithFallback
  include ::ActiveSupport::Cache::SerializerWithFallback
  def _load(entry); end

  def dump(entry); end

  def dump_compressed(entry, threshold); end

  def dumped?(dumped); end
end

module ActiveSupport::Cache::SerializerWithFallback::PassthroughWithFallback
  extend ::ActiveSupport::Cache::SerializerWithFallback::PassthroughWithFallback
  extend ::ActiveSupport::Cache::SerializerWithFallback
end

module ActiveSupport::Cache::SerializerWithFallback
  def self.[](format); end
end

class ActiveSupport::Cache::Store
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete(name, options=T.unsafe(nil)); end

  def delete_matched(matcher, options=T.unsafe(nil)); end

  def delete_multi(names, options=T.unsafe(nil)); end

  def exist?(name, options=T.unsafe(nil)); end

  def fetch(name, options=T.unsafe(nil), &block); end

  def fetch_multi(*names); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def logger(); end

  def logger=(val); end

  def mute(); end

  def new_entry(value, options=T.unsafe(nil)); end

  def options(); end

  def raise_on_invalid_cache_expiration_time(); end

  def raise_on_invalid_cache_expiration_time=(val); end

  def read(name, options=T.unsafe(nil)); end

  def read_multi(*names); end

  def silence(); end

  def silence!(); end

  def silence?(); end

  def write(name, value, options=T.unsafe(nil)); end

  def write_multi(hash, options=T.unsafe(nil)); end
end

class ActiveSupport::Cache::Store
  def self.logger(); end

  def self.logger=(val); end

  def self.raise_on_invalid_cache_expiration_time(); end

  def self.raise_on_invalid_cache_expiration_time=(val); end
end

module ActiveSupport::Cache::Strategy
end

module ActiveSupport::Cache::Strategy::LocalCache
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_matched(matcher, options=T.unsafe(nil)); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def middleware(); end

  def with_local_cache(&block); end
end

module ActiveSupport::Cache::Strategy::LocalCache
end

module ActiveSupport::Cache::Strategy
end

class ActiveSupport::Cache::WriteOptions
  def expires_at(); end

  def expires_at=(expires_at); end

  def expires_in(); end

  def expires_in=(expires_in); end

  def initialize(options); end

  def version(); end

  def version=(version); end
end

class ActiveSupport::Cache::WriteOptions
end

module ActiveSupport::Cache
  def self.expand_cache_key(key, namespace=T.unsafe(nil)); end

  def self.format_version(); end

  def self.format_version=(format_version); end

  def self.lookup_store(store=T.unsafe(nil), *parameters); end
end

module ActiveSupport::Callbacks
  CALLBACK_FILTER_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::CodeGenerator
  def define_cached_method(canonical_name, namespace:, as: T.unsafe(nil), &block); end

  def execute(); end

  def initialize(owner, path, line); end
end

class ActiveSupport::CodeGenerator::MethodSet
  def apply(owner, path, line); end

  def define_cached_method(canonical_name, as: T.unsafe(nil)); end

  def initialize(namespace); end
  METHOD_CACHES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::CodeGenerator::MethodSet
end

class ActiveSupport::CodeGenerator
  def self.batch(owner, path, line); end
end

module ActiveSupport::Configurable
  def config(); end
end

module ActiveSupport::Configurable::ClassMethods
  def config(); end

  def configure(); end
end

class ActiveSupport::Configurable::Configuration
  def compile_methods!(); end
end

class ActiveSupport::Configurable::Configuration
  def self.compile_methods!(keys); end
end

module ActiveSupport::Configurable
  extend ::ActiveSupport::Concern
end

class ActiveSupport::ConfigurationFile
  def initialize(content_path); end

  def parse(context: T.unsafe(nil), **options); end
end

class ActiveSupport::ConfigurationFile::FormatError
end

class ActiveSupport::ConfigurationFile::FormatError
end

class ActiveSupport::ConfigurationFile
  def self.parse(content_path, **options); end
end

module ActiveSupport::CoreExt::ERBUtil
  def h(s); end

  def html_escape(s); end

  def unwrapped_html_escape(s); end
end

module ActiveSupport::CoreExt::ERBUtil
end

module ActiveSupport::CoreExt::ERBUtilPrivate
  include ::ActiveSupport::CoreExt::ERBUtil
end

module ActiveSupport::CoreExt::ERBUtilPrivate
end

class ActiveSupport::CurrentAttributes
  def attributes(); end

  def attributes=(attributes); end

  def defaults(); end

  def defaults?(); end

  def reset(); end

  def set(attributes, &block); end
  INVALID_ATTRIBUTE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Delegation
  RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Deprecation
  include ::ActiveSupport::Deprecation::Behavior
  include ::ActiveSupport::Deprecation::Reporting
  include ::ActiveSupport::Deprecation::Disallowed
  include ::ActiveSupport::Deprecation::MethodWrapper
  def deprecation_horizon(); end

  def deprecation_horizon=(deprecation_horizon); end

  def initialize(deprecation_horizon=T.unsafe(nil), gem_name=T.unsafe(nil)); end
end

module ActiveSupport::Deprecation::Behavior
  def behavior(); end

  def behavior=(behavior); end

  def debug(); end

  def debug=(debug); end

  def disallowed_behavior(); end

  def disallowed_behavior=(behavior); end
end

module ActiveSupport::Deprecation::Behavior
end

module ActiveSupport::Deprecation::DeprecatedConstantAccessor
end

module ActiveSupport::Deprecation::DeprecatedConstantAccessor
  def self.included(base); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
  def append_features(base); end

  def extended(base); end

  def hash(*arg, **arg1, &arg2); end

  def initialize(old_const, new_const, deprecator, message: T.unsafe(nil)); end

  def instance_methods(*arg, **arg1, &arg2); end

  def name(*arg, **arg1, &arg2); end

  def prepend_features(base); end

  def respond_to?(*arg, **arg1, &arg2); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
  def self.new(*args, **options, &block); end
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
  def initialize(instance, method, var=T.unsafe(nil), deprecator:); end
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
  def initialize(object, message, deprecator); end
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
  def self.new(*args, **kwargs, &block); end
end

class ActiveSupport::Deprecation::Deprecators
  def [](name); end

  def []=(name, deprecator); end

  def behavior=(behavior); end

  def debug=(debug); end

  def disallowed_behavior=(disallowed_behavior); end

  def disallowed_warnings=(disallowed_warnings); end

  def each(&block); end

  def silence(&block); end

  def silenced=(silenced); end
end

class ActiveSupport::Deprecation::Deprecators
end

module ActiveSupport::Deprecation::Disallowed
  def disallowed_warnings(); end

  def disallowed_warnings=(disallowed_warnings); end
end

module ActiveSupport::Deprecation::Disallowed
end

module ActiveSupport::Deprecation::MethodWrapper
  def deprecate_methods(target_module, *method_names); end
end

module ActiveSupport::Deprecation::MethodWrapper
end

module ActiveSupport::Deprecation::Reporting
  def allow(allowed_warnings=T.unsafe(nil), if: T.unsafe(nil), &block); end

  def begin_silence(); end

  def deprecation_warning(deprecated_method_name, message=T.unsafe(nil), caller_backtrace=T.unsafe(nil)); end

  def end_silence(); end

  def gem_name(); end

  def gem_name=(gem_name); end

  def silence(&block); end

  def silenced(); end

  def silenced=(silenced); end

  def warn(message=T.unsafe(nil), callstack=T.unsafe(nil)); end
  LIB_DIR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Deprecation
  def self._instance(); end
end

class ActiveSupport::Digest
end

class ActiveSupport::Digest
  def self.hash_digest_class(); end

  def self.hash_digest_class=(klass); end

  def self.hexdigest(arg); end
end

class ActiveSupport::Duration
  PARTS = ::T.let(nil, ::T.untyped)
  PARTS_IN_SECONDS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
  SECONDS_PER_HOUR = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MINUTE = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MONTH = ::T.let(nil, ::T.untyped)
  SECONDS_PER_WEEK = ::T.let(nil, ::T.untyped)
  SECONDS_PER_YEAR = ::T.let(nil, ::T.untyped)
  VARIABLE_PARTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser
  def initialize(string); end

  def mode(); end

  def mode=(mode); end

  def parse!(); end

  def parts(); end

  def scanner(); end

  def sign(); end

  def sign=(sign); end
  COMMA = ::T.let(nil, ::T.untyped)
  DATE_COMPONENT = ::T.let(nil, ::T.untyped)
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
  DATE_MARKER = ::T.let(nil, ::T.untyped)
  DATE_TO_PART = ::T.let(nil, ::T.untyped)
  PERIOD = ::T.let(nil, ::T.untyped)
  PERIOD_OR_COMMA = ::T.let(nil, ::T.untyped)
  SIGN_MARKER = ::T.let(nil, ::T.untyped)
  TIME_COMPONENT = ::T.let(nil, ::T.untyped)
  TIME_COMPONENTS = ::T.let(nil, ::T.untyped)
  TIME_MARKER = ::T.let(nil, ::T.untyped)
  TIME_TO_PART = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser
end

class ActiveSupport::Duration::ISO8601Serializer
  def initialize(duration, precision: T.unsafe(nil)); end

  def serialize(); end
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Serializer
end

class ActiveSupport::EnumerableCoreExt::SoleItemExpectedError
end

class ActiveSupport::EnumerableCoreExt::SoleItemExpectedError
end

class ActiveSupport::EnvironmentInquirer
  def development?(); end

  def initialize(env); end

  def local?(); end

  def production?(); end

  def test?(); end
  DEFAULT_ENVIRONMENTS = ::T.let(nil, ::T.untyped)
  LOCAL_ENVIRONMENTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::EnvironmentInquirer
end

class ActiveSupport::ErrorReporter
  DEFAULT_RESCUE = ::T.let(nil, ::T.untyped)
  DEFAULT_SOURCE = ::T.let(nil, ::T.untyped)
  SEVERITIES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::ExecutionContext
end

module ActiveSupport::ExecutionContext
  def self.[]=(key, value); end

  def self.after_change(&block); end

  def self.clear(); end

  def self.set(**options); end

  def self.to_h(); end
end

class ActiveSupport::ExecutionWrapper
  Null = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::ForkTracker
end

module ActiveSupport::ForkTracker::CoreExt
  def _fork(); end
end

module ActiveSupport::ForkTracker::CoreExt
end

module ActiveSupport::ForkTracker
  def self.after_fork(&block); end

  def self.after_fork_callback(); end

  def self.hook!(); end

  def self.unregister(callback); end
end

module ActiveSupport::Gzip
end

class ActiveSupport::Gzip::Stream
  def initialize(*arg); end
end

class ActiveSupport::Gzip::Stream
end

module ActiveSupport::Gzip
  def self.compress(source, level=T.unsafe(nil), strategy=T.unsafe(nil)); end

  def self.decompress(source); end
end

class ActiveSupport::HashWithIndifferentAccess
  NOT_GIVEN = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Inflector
  ALLOWED_ENCODINGS_FOR_TRANSLITERATE = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::InheritableOptions
  def ==(other); end

  def each(&block); end

  def key?(key); end

  def overridden?(key); end

  def pretty_print(pp); end
end

module ActiveSupport::JSON::Encoding
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
  def encode(value); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
end

module ActiveSupport::JSON::Encoding
  def self.escape_html_entities_in_json(); end

  def self.escape_html_entities_in_json=(escape_html_entities_in_json); end

  def self.json_encoder(); end

  def self.json_encoder=(json_encoder); end

  def self.time_precision(); end

  def self.time_precision=(time_precision); end

  def self.use_standard_json_time_format(); end

  def self.use_standard_json_time_format=(use_standard_json_time_format); end
end

module ActiveSupport::JSON
  def self.decode(json); end

  def self.dump(value, options=T.unsafe(nil)); end

  def self.encode(value, options=T.unsafe(nil)); end

  def self.load(json); end

  def self.parse_error(); end
end

class ActiveSupport::KeyGenerator
  def generate_key(salt, key_size=T.unsafe(nil)); end

  def initialize(secret, options=T.unsafe(nil)); end
end

class ActiveSupport::KeyGenerator
  def self.hash_digest_class(); end

  def self.hash_digest_class=(klass); end
end

class ActiveSupport::LogSubscriber
  def colorize_logging(); end

  def colorize_logging=(val); end

  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def event_levels=(event_levels); end

  def fatal(progname=T.unsafe(nil), &block); end

  def info(progname=T.unsafe(nil), &block); end

  def logger(); end

  def silenced?(event); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end
  LEVEL_CHECKS = ::T.let(nil, ::T.untyped)
  MODES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::LogSubscriber
  def self.attach_to(*arg, **arg1, &arg2); end

  def self.colorize_logging(); end

  def self.colorize_logging=(val); end

  def self.flush_all!(); end

  def self.log_levels(); end

  def self.log_levels=(value); end

  def self.log_levels?(); end

  def self.log_subscribers(); end

  def self.logger(); end

  def self.logger=(logger); end
end

class ActiveSupport::MessageEncryptor
  include ::ActiveSupport::Messages::Rotator
  def create_message(value, **options); end

  def decrypt_and_verify(message, **options); end

  def encrypt_and_sign(value, **options); end
  AUTH_TAG_LENGTH = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

module ActiveSupport::MessageEncryptor::NullSerializer
end

module ActiveSupport::MessageEncryptor::NullSerializer
  def self.dump(value); end

  def self.load(value); end
end

ActiveSupport::MessageEncryptor::OpenSSLCipherError = OpenSSL::Cipher::CipherError

class ActiveSupport::MessageEncryptor
  def self.default_cipher(); end

  def self.key_len(cipher=T.unsafe(nil)); end

  def self.use_authenticated_message_encryption(); end

  def self.use_authenticated_message_encryption=(val); end
end

class ActiveSupport::MessageEncryptors
end

class ActiveSupport::MessageEncryptors
end

class ActiveSupport::MessageVerifier
  include ::ActiveSupport::Messages::Rotator
  def create_message(value, **options); end

  def generate(value, **options); end

  def valid_message?(message); end

  def verified(message, **options); end

  def verify(message, **options); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_LENGTH = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier
end

class ActiveSupport::MessageVerifiers
end

class ActiveSupport::MessageVerifiers
end

class ActiveSupport::Messages::Codec
  include ::ActiveSupport::Messages::Metadata
  def initialize(**options); end
end

class ActiveSupport::Messages::Codec
  def self.default_serializer(); end

  def self.default_serializer=(value); end
end

module ActiveSupport::Messages::Metadata
  ENVELOPE_SERIALIZERS = ::T.let(nil, ::T.untyped)
  TIMESTAMP_SERIALIZERS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Messages::Metadata
  def self.use_message_serializer_for_metadata(); end

  def self.use_message_serializer_for_metadata=(use_message_serializer_for_metadata); end
end

class ActiveSupport::Messages::RotationCoordinator
  def [](salt); end

  def []=(salt, codec); end

  def clear_rotations(); end

  def initialize(&secret_generator); end

  def on_rotation(&callback); end

  def rotate(**options, &block); end

  def rotate_defaults(); end

  def transitional(); end

  def transitional=(transitional); end
end

class ActiveSupport::Messages::RotationCoordinator
end

module ActiveSupport::Messages::Rotator
  def fall_back_to(fallback); end

  def initialize(*args, on_rotation: T.unsafe(nil), **options); end

  def read_message(message, on_rotation: T.unsafe(nil), **options); end

  def rotate(*args, **options); end
end

module ActiveSupport::Messages::Rotator
end

class ActiveSupport::Multibyte::Chars
  include ::Comparable
  def =~(*arg, **arg1, &arg2); end

  def acts_like_string?(*arg, **arg1, &arg2); end

  def compose(); end

  def decompose(); end

  def grapheme_length(); end

  def initialize(string); end

  def limit(limit); end

  def match?(*arg, **arg1, &arg2); end

  def method_missing(method, *arg, **arg1, &arg2); end

  def reverse(); end

  def reverse!(*args); end

  def slice!(*args); end

  def split(*args); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def wrapped_string(); end
end

class ActiveSupport::Multibyte::Chars
end

module ActiveSupport::Multibyte::Unicode
  def compose(codepoints); end

  def decompose(type, codepoints); end

  def tidy_bytes(string, force=T.unsafe(nil)); end
end

module ActiveSupport::Multibyte::Unicode
  extend ::ActiveSupport::Multibyte::Unicode
end

module ActiveSupport::Notifications
end

class ActiveSupport::Notifications::Event
  def allocations(); end

  def cpu_time(); end

  def duration(); end

  def end(); end

  def finish!(); end

  def gc_time(); end

  def idle_time(); end

  def initialize(name, start, ending, transaction_id, payload); end

  def name(); end

  def payload(); end

  def payload=(payload); end

  def record(); end

  def start!(); end

  def time(); end

  def transaction_id(); end
end

class ActiveSupport::Notifications::Event
end

class ActiveSupport::Notifications::Fanout
  include ::ActiveSupport::Notifications::FanoutIteration
  def all_listeners_for(name); end

  def build_handle(name, id, payload); end

  def clear_cache(key=T.unsafe(nil)); end

  def finish(name, id, payload, listeners=T.unsafe(nil)); end

  def groups_for(name); end

  def listeners_for(name); end

  def listening?(name); end

  def publish(name, *args); end

  def publish_event(event); end

  def start(name, id, payload); end

  def subscribe(pattern=T.unsafe(nil), callable=T.unsafe(nil), monotonic: T.unsafe(nil), &block); end

  def unsubscribe(subscriber_or_name); end

  def wait(); end
end

class ActiveSupport::Notifications::Fanout::BaseGroup
  include ::ActiveSupport::Notifications::FanoutIteration
  def each(&block); end

  def initialize(listeners, name, id, payload); end
end

class ActiveSupport::Notifications::Fanout::BaseGroup
end

class ActiveSupport::Notifications::Fanout::BaseTimeGroup
  def finish(name, id, payload); end

  def start(name, id, payload); end
end

class ActiveSupport::Notifications::Fanout::BaseTimeGroup
end

class ActiveSupport::Notifications::Fanout::EventObjectGroup
  def finish(name, id, payload); end

  def start(name, id, payload); end
end

class ActiveSupport::Notifications::Fanout::EventObjectGroup
end

class ActiveSupport::Notifications::Fanout::EventedGroup
  def finish(name, id, payload); end

  def start(name, id, payload); end
end

class ActiveSupport::Notifications::Fanout::EventedGroup
end

class ActiveSupport::Notifications::Fanout::Handle
  include ::ActiveSupport::Notifications::FanoutIteration
  def finish(); end

  def finish_with_values(name, id, payload); end

  def initialize(notifier, name, id, payload); end

  def start(); end
end

class ActiveSupport::Notifications::Fanout::Handle
end

class ActiveSupport::Notifications::Fanout::MonotonicTimedGroup
end

class ActiveSupport::Notifications::Fanout::MonotonicTimedGroup
end

module ActiveSupport::Notifications::Fanout::Subscribers
end

class ActiveSupport::Notifications::Fanout::Subscribers::EventObject
end

class ActiveSupport::Notifications::Fanout::Subscribers::EventObject
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def delegate(); end

  def group_class(); end

  def initialize(pattern, delegate); end

  def pattern(); end

  def publish(name, *args); end

  def publish_event(event); end

  def silenceable(); end

  def silenced?(name); end

  def subscribed_to?(name); end

  def unsubscribe!(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  def ===(name); end

  def exclusions(); end

  def initialize(pattern); end

  def pattern(); end

  def unsubscribe!(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher::AllMessages
  def ===(name); end

  def unsubscribe!(*arg); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher::AllMessages
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  def self.wrap(pattern); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::MonotonicTimed
end

class ActiveSupport::Notifications::Fanout::Subscribers::MonotonicTimed
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

module ActiveSupport::Notifications::Fanout::Subscribers
  def self.new(pattern, listener, monotonic); end
end

class ActiveSupport::Notifications::Fanout::TimedGroup
end

class ActiveSupport::Notifications::Fanout::TimedGroup
end

class ActiveSupport::Notifications::Fanout
end

module ActiveSupport::Notifications::FanoutIteration
end

module ActiveSupport::Notifications::FanoutIteration
end

class ActiveSupport::Notifications::InstrumentationSubscriberError
  def exceptions(); end

  def initialize(exceptions); end
end

class ActiveSupport::Notifications::InstrumentationSubscriberError
end

class ActiveSupport::Notifications::Instrumenter
  def build_handle(name, payload); end

  def finish(name, payload); end

  def finish_with_state(listeners_state, name, payload); end

  def id(); end

  def initialize(notifier); end

  def instrument(name, payload=T.unsafe(nil)); end

  def new_event(name, payload=T.unsafe(nil)); end

  def start(name, payload); end
end

class ActiveSupport::Notifications::Instrumenter::LegacyHandle
  def finish(); end

  def initialize(notifier, name, id, payload); end

  def start(); end
end

class ActiveSupport::Notifications::Instrumenter::LegacyHandle::Wrapper
  def build_handle(name, id, payload); end

  def finish(*arg, **arg1, &arg2); end

  def initialize(notifier); end

  def start(*arg, **arg1, &arg2); end
end

class ActiveSupport::Notifications::Instrumenter::LegacyHandle::Wrapper
end

class ActiveSupport::Notifications::Instrumenter::LegacyHandle
end

class ActiveSupport::Notifications::Instrumenter
end

module ActiveSupport::Notifications
  def self.instrument(name, payload=T.unsafe(nil)); end

  def self.instrumenter(); end

  def self.monotonic_subscribe(pattern=T.unsafe(nil), callback=T.unsafe(nil), &block); end

  def self.notifier(); end

  def self.notifier=(notifier); end

  def self.publish(name, *args); end

  def self.publish_event(event); end

  def self.subscribe(pattern=T.unsafe(nil), callback=T.unsafe(nil), &block); end

  def self.subscribed(callback, pattern=T.unsafe(nil), monotonic: T.unsafe(nil), &block); end

  def self.unsubscribe(subscriber_or_name); end
end

class ActiveSupport::NumberHelper::NumberConverter
  def execute(); end

  def initialize(number, options); end

  def namespace(); end

  def namespace=(namespace); end

  def namespace?(); end

  def number(); end

  def opts(); end

  def validate_float(); end

  def validate_float=(validate_float); end

  def validate_float?(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberConverter
  def self.convert(number, options); end

  def self.namespace(); end

  def self.namespace=(value); end

  def self.namespace?(); end

  def self.validate_float(); end

  def self.validate_float=(value); end

  def self.validate_float?(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
  def convert(); end
  DEFAULT_DELIMITER_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
  def convert(); end
  DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
  INVERTED_DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
  def convert(); end
  STORAGE_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
end

class ActiveSupport::NumberHelper::RoundingHelper
  def digit_count(number); end

  def initialize(options); end

  def options(); end

  def round(number); end
end

class ActiveSupport::NumberHelper::RoundingHelper
end

module ActiveSupport::NumberHelper
  extend ::ActiveSupport::Autoload
end

class ActiveSupport::OptionMerger
  def initialize(context, options); end
end

class ActiveSupport::OptionMerger
end

class ActiveSupport::OrderedHash
  def encode_with(coder); end

  def nested_under_indifferent_access(); end

  def reject(*args, &block); end

  def select(*args, &block); end

  def to_yaml_type(); end
end

class ActiveSupport::OrderedOptions
  def [](key); end

  def []=(key, value); end

  def _get(arg); end

  def dig(key, *identifiers); end

  def method_missing(method, *args); end
end

class ActiveSupport::ProxyObject
  def raise(*args); end
end

class ActiveSupport::ProxyObject
  def self.inherited(_subclass); end
end

class ActiveSupport::Reloader
  def _class_unload_callbacks(); end

  def _prepare_callbacks(); end

  def _run_class_unload_callbacks(&block); end

  def _run_prepare_callbacks(&block); end

  def check(); end

  def check=(check); end

  def check?(); end

  def class_unload!(&block); end

  def executor(); end

  def executor=(executor); end

  def executor?(); end

  def release_unload_lock!(); end

  def require_unload_lock!(); end
end

class ActiveSupport::Reloader
  def self._class_unload_callbacks(); end

  def self._class_unload_callbacks=(value); end

  def self._prepare_callbacks(); end

  def self._prepare_callbacks=(value); end

  def self.after_class_unload(*args, &block); end

  def self.before_class_unload(*args, &block); end

  def self.check(); end

  def self.check!(); end

  def self.check=(value); end

  def self.check?(); end

  def self.executor(); end

  def self.executor=(value); end

  def self.executor?(); end

  def self.prepare!(); end

  def self.reload!(); end

  def self.reloaded!(); end

  def self.to_prepare(*args, &block); end

  def self.wrap(**kwargs); end
end

module ActiveSupport::Rescuable
  def handler_for_rescue(exception); end

  def rescue_with_handler(exception); end
end

module ActiveSupport::Rescuable::ClassMethods
  def handler_for_rescue(exception, object: T.unsafe(nil)); end

  def rescue_with_handler(exception, object: T.unsafe(nil), visited_exceptions: T.unsafe(nil)); end
end

module ActiveSupport::Rescuable
  extend ::ActiveSupport::Concern
end

class ActiveSupport::SafeBuffer
  def %(args); end

  def *(_); end

  def +(other); end

  def <<(value); end

  def [](*args); end

  def []=(arg1, arg2, arg3=T.unsafe(nil)); end

  def bytesplice(*args, value); end

  def capitalize(*args, &block); end

  def capitalize!(*args); end

  def chomp(*args, &block); end

  def chomp!(*args); end

  def chop(*args, &block); end

  def chop!(*args); end

  def concat(value); end

  def delete(*args, &block); end

  def delete!(*args); end

  def delete_prefix(*args, &block); end

  def delete_prefix!(*args); end

  def delete_suffix(*args, &block); end

  def delete_suffix!(*args); end

  def downcase(*args, &block); end

  def downcase!(*args); end

  def encode_with(coder); end

  def gsub(*args, &block); end

  def gsub!(*args, &block); end

  def initialize(str=T.unsafe(nil)); end

  def insert(index, value); end

  def lstrip(*args, &block); end

  def lstrip!(*args); end

  def next(*args, &block); end

  def next!(*args); end

  def prepend(value); end

  def replace(value); end

  def reverse(*args, &block); end

  def reverse!(*args); end

  def rstrip(*args, &block); end

  def rstrip!(*args); end

  def safe_concat(value); end

  def scrub(*args, &block); end

  def scrub!(*args); end

  def slice(*args); end

  def slice!(*args); end

  def squeeze(*args, &block); end

  def squeeze!(*args); end

  def strip(*args, &block); end

  def strip!(*args); end

  def sub(*args, &block); end

  def sub!(*args, &block); end

  def succ(*args, &block); end

  def succ!(*args); end

  def swapcase(*args, &block); end

  def swapcase!(*args); end

  def tr(*args, &block); end

  def tr!(*args); end

  def tr_s(*args, &block); end

  def tr_s!(*args); end

  def unicode_normalize(*args, &block); end

  def unicode_normalize!(*args); end

  def upcase(*args, &block); end

  def upcase!(*args); end
end

class ActiveSupport::SafeBuffer::SafeConcatError
  def initialize(); end
end

class ActiveSupport::SafeBuffer::SafeConcatError
end

class ActiveSupport::SecureCompareRotator
  include ::ActiveSupport::SecurityUtils
  def initialize(value, on_rotation: T.unsafe(nil)); end

  def rotate(previous_value); end

  def secure_compare!(other_value, on_rotation: T.unsafe(nil)); end
end

class ActiveSupport::SecureCompareRotator::InvalidMatch
end

class ActiveSupport::SecureCompareRotator::InvalidMatch
end

class ActiveSupport::SecureCompareRotator
end

module ActiveSupport::SecurityUtils
end

module ActiveSupport::SecurityUtils
  def self.fixed_length_secure_compare(a, b); end

  def self.secure_compare(a, b); end
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::Subscriber
  def call(event); end

  def patterns(); end

  def publish_event(event); end
end

class ActiveSupport::Subscriber
  def self.attach_to(namespace, subscriber=T.unsafe(nil), notifier=T.unsafe(nil), inherit_all: T.unsafe(nil)); end

  def self.detach_from(namespace, notifier=T.unsafe(nil)); end

  def self.method_added(event); end

  def self.subscribers(); end
end

module ActiveSupport::TaggedLogging
  def clear_tags!(*arg, **arg1, &arg2); end

  def flush(); end

  def pop_tags(*arg, **arg1, &arg2); end

  def push_tags(*arg, **arg1, &arg2); end

  def tagged(*tags); end
end

module ActiveSupport::TaggedLogging::Formatter
  def call(severity, timestamp, progname, msg); end

  def clear_tags!(); end

  def current_tags(); end

  def pop_tags(count=T.unsafe(nil)); end

  def push_tags(*tags); end

  def tag_stack(); end

  def tagged(*tags); end

  def tags_text(); end
end

module ActiveSupport::TaggedLogging::Formatter
end

module ActiveSupport::TaggedLogging::LocalTagStorage
  def tag_stack(); end

  def tag_stack=(tag_stack); end
end

module ActiveSupport::TaggedLogging::LocalTagStorage
  def self.extended(base); end
end

class ActiveSupport::TaggedLogging::TagStack
  def clear(); end

  def format_message(message); end

  def pop_tags(count); end

  def push_tags(tags); end

  def tags(); end
end

class ActiveSupport::TaggedLogging::TagStack
end

module ActiveSupport::TaggedLogging
  def self.new(logger); end
end

class ActiveSupport::TestCase
  include ::ActiveSupport::Testing::TaggedLogging
  include ::ActiveSupport::Callbacks
  include ::ActiveSupport::Testing::Assertions
  include ::ActiveSupport::Testing::ErrorReporterAssertions
  include ::ActiveSupport::Testing::Deprecation
  include ::ActiveSupport::Testing::ConstantStubbing
  include ::ActiveSupport::Testing::TimeHelpers
  include ::ActiveSupport::Testing::FileFixtures
  include ::ActiveSupport::Testing::SetupAndTeardown
  include ::ActiveSupport::Testing::TestsWithoutAssertions
  def __callbacks(); end

  def __callbacks?(); end

  def _run_setup_callbacks(&block); end

  def _run_teardown_callbacks(&block); end

  def _setup_callbacks(); end

  def _teardown_callbacks(); end

  def assert_no_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_not_empty(obj, msg=T.unsafe(nil)); end

  def assert_not_equal(exp, act, msg=T.unsafe(nil)); end

  def assert_not_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_includes(collection, obj, msg=T.unsafe(nil)); end

  def assert_not_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_nil(obj, msg=T.unsafe(nil)); end

  def assert_not_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_not_respond_to(obj, meth, msg=T.unsafe(nil), include_all: T.unsafe(nil)); end

  def assert_not_same(exp, act, msg=T.unsafe(nil)); end

  def file_fixture_path(); end

  def file_fixture_path?(); end

  def method_name(); end
end

ActiveSupport::TestCase::Assertion = Minitest::Assertion

class ActiveSupport::TestCase
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._setup_callbacks(); end

  def self._setup_callbacks=(value); end

  def self._teardown_callbacks(); end

  def self._teardown_callbacks=(value); end

  def self.file_fixture_path(); end

  def self.file_fixture_path=(value); end

  def self.file_fixture_path?(); end

  def self.parallelize(workers: T.unsafe(nil), with: T.unsafe(nil), threshold: T.unsafe(nil)); end

  def self.parallelize_setup(&block); end

  def self.parallelize_teardown(&block); end

  def self.test_order=(new_order); end
end

module ActiveSupport::Testing::Assertions
  def assert_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil), &block); end

  def assert_difference(expression, *args, &block); end

  def assert_no_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), &block); end

  def assert_no_difference(expression, message=T.unsafe(nil), &block); end

  def assert_not(object, message=T.unsafe(nil)); end

  def assert_nothing_raised(); end

  def assert_raise(*exp, match: T.unsafe(nil), &block); end

  def assert_raises(*exp, match: T.unsafe(nil), &block); end
  UNTRACKED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Assertions
end

module ActiveSupport::Testing::ConstantStubbing
  def stub_const(mod, constant, new_value, exists: T.unsafe(nil)); end
end

module ActiveSupport::Testing::ConstantStubbing
end

module ActiveSupport::Testing::Deprecation
  def assert_deprecated(match=T.unsafe(nil), deprecator=T.unsafe(nil), &block); end

  def assert_not_deprecated(deprecator, &block); end

  def collect_deprecations(deprecator); end
end

module ActiveSupport::Testing::Deprecation
end

module ActiveSupport::Testing::ErrorReporterAssertions
  def assert_error_reported(error_class=T.unsafe(nil), &block); end

  def assert_no_error_reported(&block); end
end

module ActiveSupport::Testing::ErrorReporterAssertions
end

module ActiveSupport::Testing::FileFixtures
  def file_fixture(fixture_name); end
end

module ActiveSupport::Testing::FileFixtures
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Testing::SetupAndTeardown
  def after_teardown(); end

  def before_setup(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def self.prepended(klass); end
end

module ActiveSupport::Testing::TaggedLogging
  def before_setup(); end

  def tagged_logger=(tagged_logger); end
end

module ActiveSupport::Testing::TaggedLogging
end

module ActiveSupport::Testing::TestsWithoutAssertions
  def after_teardown(); end
end

module ActiveSupport::Testing::TestsWithoutAssertions
end

module ActiveSupport::Testing::TimeHelpers
  def after_teardown(); end

  def freeze_time(with_usec: T.unsafe(nil), &block); end

  def travel(duration, with_usec: T.unsafe(nil), &block); end

  def travel_back(); end

  def travel_to(date_or_time, with_usec: T.unsafe(nil)); end

  def unfreeze_time(); end
end

module ActiveSupport::Testing::TimeHelpers
end

class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  PRECISIONS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  MAPPING = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_json(options=T.unsafe(nil)); end
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini
  def backend(); end

  def backend=(name); end

  def depth(); end

  def depth=(depth); end

  def parse(*arg, **arg1, &arg2); end

  def rename_key(key, options=T.unsafe(nil)); end

  def to_tag(key, value, options); end

  def with_backend(name); end
  DEFAULT_ENCODINGS = ::T.let(nil, ::T.untyped)
  FORMATTING = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini::FileLike
  def content_type(); end

  def content_type=(content_type); end

  def original_filename(); end

  def original_filename=(original_filename); end
end

module ActiveSupport::XmlMini::FileLike
end

module ActiveSupport::XmlMini
  extend ::ActiveSupport::XmlMini
end

module ActiveSupport
  def self.escape_html_entities_in_json(*arg, **arg1, &arg2); end

  def self.escape_html_entities_in_json=(arg); end

  def self.json_encoder(*arg, **arg1, &arg2); end

  def self.json_encoder=(arg); end

  def self.parse_json_times(); end

  def self.parse_json_times=(val); end

  def self.time_precision(*arg, **arg1, &arg2); end

  def self.time_precision=(arg); end

  def self.use_standard_json_time_format(*arg, **arg1, &arg2); end

  def self.use_standard_json_time_format=(arg); end
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class ArgumentError
  include ::ErrorHighlight::CoreExt
end

class Array
  def deconstruct(); end

  def to_h(); end
end

class Array
  def self.new(*arg); end

  def self.try_convert(arg); end
end

module Base64
  VERSION = ::T.let(nil, ::T.untyped)
end

BasicObject::BasicObject = BasicObject

class BasicSocket
  def read_nonblock(len, str=T.unsafe(nil), exception: T.unsafe(nil)); end
end

class BigDecimal
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  def to_digits(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Binding
  def clone(); end
end

class Bundler::APIResponseInvalidDependenciesError
  def status_code(); end
end

class Bundler::APIResponseInvalidDependenciesError
end

module Bundler::CIDetector
  ENV_DESCRIPTORS = ::T.let(nil, ::T.untyped)
  ENV_INDICATORS = ::T.let(nil, ::T.untyped)
end

module Bundler::CIDetector
  def self.ci?(); end

  def self.ci_strings(); end
end

class Bundler::CLI
  def add(*gems); end

  def binstubs(*gems); end

  def cache(); end

  def check(); end

  def clean(); end

  def cli_help(); end

  def config(*args); end

  def console(group=T.unsafe(nil)); end

  def doctor(); end

  def env(); end

  def exec(*args); end

  def fund(); end

  def help(cli=T.unsafe(nil)); end

  def info(gem_name); end

  def init(); end

  def initialize(*args); end

  def inject(name, version); end

  def install(); end

  def issue(); end

  def licenses(); end

  def list(); end

  def lock(); end

  def open(name); end

  def outdated(*gems); end

  def platform(); end

  def plugin(*args); end

  def pristine(*gems); end

  def remove(*gems); end

  def show(gem_name=T.unsafe(nil)); end

  def update(*gems); end

  def version(); end

  def viz(); end
  AUTO_INSTALL_CMDS = ::T.let(nil, ::T.untyped)
  COMMAND_ALIASES = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  PARSEABLE_COMMANDS = ::T.let(nil, ::T.untyped)
end

module Bundler::CLI::Common
end

module Bundler::CLI::Common
  def self.ask_for_spec_from(specs); end

  def self.clean_after_install?(); end

  def self.configure_gem_version_promoter(definition, options); end

  def self.default_gem_spec(name); end

  def self.ensure_all_gems_in_lockfile!(names, locked_gems=T.unsafe(nil)); end

  def self.gem_not_found_message(missing_gem_name, alternatives); end

  def self.output_fund_metadata_summary(); end

  def self.output_post_install_messages(messages); end

  def self.output_without_groups_message(command); end

  def self.patch_level_options(options); end

  def self.print_post_install_message(name, msg); end

  def self.select_spec(name, regex_match=T.unsafe(nil)); end

  def self.verbalize_groups(groups); end

  def self.without_groups_message(command); end
end

class Bundler::CLI::Config
  def base(name=T.unsafe(nil), *value); end

  def get(name); end

  def list(); end

  def set(name, value, *value_); end

  def unset(name); end
end

class Bundler::CLI::Config::Base
  def confirm(name); end

  def confirm_all(); end

  def explicit_scope?(); end

  def initialize(options, name, value, thor); end

  def message(); end

  def name(); end

  def new_value(); end

  def options(); end

  def run(); end

  def scope(); end

  def show_pretty_values_for(setting); end

  def thor(); end

  def validate_scope!(); end

  def value(); end

  def warn_unused_scope(msg); end
end

class Bundler::CLI::Config::Base
end

class Bundler::CLI::Config
end

class Bundler::CLI::Install
  def initialize(options); end

  def options(); end

  def run(); end
end

class Bundler::CLI::Install
end

class Bundler::CLI::Plugin
  def install(*plugins); end

  def list(); end

  def uninstall(*plugins); end
end

class Bundler::CLI::Plugin
end

class Bundler::CLI
  def self.aliases_for(command_name); end

  def self.all_aliases(); end

  def self.check_deprecated_ext_option(arguments); end

  def self.deprecated_ext_value?(arguments); end

  def self.dispatch(*arg); end

  def self.reformatted_help_args(args); end

  def self.source_root(); end

  def self.start(*arg); end
end

class Bundler::Checksum
  def ==(other); end

  def algo(); end

  def digest(); end

  def eql?(other); end

  def formatted_sources(); end

  def initialize(algo, digest, source); end

  def match?(other); end

  def merge!(other); end

  def removable?(); end

  def removal_instructions(); end

  def same_source?(other); end

  def sources(); end

  def to_lock(); end
  ALGO_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Bundler::Checksum::Source
  def ==(other); end

  def initialize(type, location); end

  def location(); end

  def removable?(); end

  def removal(); end

  def type(); end
end

class Bundler::Checksum::Source
end

class Bundler::Checksum::Store
  def merge!(other); end

  def register(spec, checksum); end

  def replace(spec, checksum); end

  def store(); end

  def to_lock(spec); end
end

class Bundler::Checksum::Store
end

class Bundler::Checksum
  def self.from_api(digest, source_uri, algo=T.unsafe(nil)); end

  def self.from_gem(io, pathname, algo=T.unsafe(nil)); end

  def self.from_gem_package(gem_package, algo=T.unsafe(nil)); end

  def self.from_lock(lock_checksum, lockfile_location); end

  def self.to_hexdigest(digest, algo=T.unsafe(nil)); end
end

class Bundler::ChecksumMismatchError
  def initialize(lock_name, existing, checksum); end

  def mismatch_resolution_instructions(); end
end

class Bundler::ChecksumMismatchError
end

class Bundler::ConnectionPool
  def auto_reload_after_fork(); end

  def available(); end

  def checkin(force: T.unsafe(nil)); end

  def checkout(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil), &block); end

  def reload(&block); end

  def shutdown(&block); end

  def size(); end

  def then(options=T.unsafe(nil)); end

  def with(options=T.unsafe(nil)); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::ConnectionPool::TimedStack
  def <<(obj, options=T.unsafe(nil)); end

  def empty?(); end

  def initialize(size=T.unsafe(nil), &block); end

  def length(); end

  def max(); end

  def pop(timeout=T.unsafe(nil), options=T.unsafe(nil)); end

  def push(obj, options=T.unsafe(nil)); end

  def shutdown(reload: T.unsafe(nil), &block); end
end

class Bundler::ConnectionPool::TimedStack
end

class Bundler::ConnectionPool
  def self.after_fork(); end

  def self.wrap(options, &block); end
end

class Bundler::CorruptBundlerInstallError
  def initialize(loaded_spec); end

  def status_code(); end
end

class Bundler::CorruptBundlerInstallError
end

class Bundler::CurrentRuby
  def jruby_30?(); end

  def jruby_31?(); end

  def jruby_32?(); end

  def jruby_33?(); end

  def jruby_3?(); end

  def maglev_30?(); end

  def maglev_31?(); end

  def maglev_32?(); end

  def maglev_33?(); end

  def maglev_3?(); end

  def mingw_30?(); end

  def mingw_31?(); end

  def mingw_32?(); end

  def mingw_33?(); end

  def mingw_3?(); end

  def mri_30?(); end

  def mri_31?(); end

  def mri_32?(); end

  def mri_33?(); end

  def mri_3?(); end

  def mswin64_30?(); end

  def mswin64_31?(); end

  def mswin64_32?(); end

  def mswin64_33?(); end

  def mswin64_3?(); end

  def mswin_30?(); end

  def mswin_31?(); end

  def mswin_32?(); end

  def mswin_33?(); end

  def mswin_3?(); end

  def on_30?(); end

  def on_31?(); end

  def on_32?(); end

  def on_33?(); end

  def on_3?(); end

  def rbx_30?(); end

  def rbx_31?(); end

  def rbx_32?(); end

  def rbx_33?(); end

  def rbx_3?(); end

  def ruby_30?(); end

  def ruby_31?(); end

  def ruby_32?(); end

  def ruby_33?(); end

  def ruby_3?(); end

  def truffleruby_30?(); end

  def truffleruby_31?(); end

  def truffleruby_32?(); end

  def truffleruby_33?(); end

  def truffleruby_3?(); end

  def windows?(); end

  def windows_18?(); end

  def windows_19?(); end

  def windows_1?(); end

  def windows_20?(); end

  def windows_21?(); end

  def windows_22?(); end

  def windows_23?(); end

  def windows_24?(); end

  def windows_25?(); end

  def windows_26?(); end

  def windows_27?(); end

  def windows_2?(); end

  def windows_30?(); end

  def windows_31?(); end

  def windows_32?(); end

  def windows_33?(); end

  def windows_3?(); end

  def x64_mingw_30?(); end

  def x64_mingw_31?(); end

  def x64_mingw_32?(); end

  def x64_mingw_33?(); end

  def x64_mingw_3?(); end
end

class Bundler::Definition
  def bundler_version_to_lock(); end

  def current_locked_dependencies(); end

  def deleted_deps(); end

  def dependencies_for(groups); end

  def filter_relevant(dependencies); end

  def locked_checksums(); end

  def locked_dependencies(); end

  def most_specific_locked_platform(); end

  def new_deps(); end

  def no_resolve_needed?(); end

  def prefer_local!(); end

  def requested_dependencies(); end

  def resolve_only_locally!(); end
end

class Bundler::Definition
  def self.no_lock(); end

  def self.no_lock=(no_lock); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def gemspec_dev_dep?(); end

  def git(); end

  def github(); end

  def glob(); end

  def path(); end

  def ref(); end
  ALL_RUBY_VERSIONS = ::T.let(nil, ::T.untyped)
end

Bundler::Deprecate = Gem::Deprecate

module Bundler::Digest
  SHA1_MASK = ::T.let(nil, ::T.untyped)
  SHA1_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Digest
  def self.sha1(string); end
end

class Bundler::DirectoryRemovalError
  def initialize(orig_exception, msg); end

  def status_code(); end
end

class Bundler::DirectoryRemovalError
end

class Bundler::Dsl
  def check_primary_source_safety(); end

  def gemfile(); end
  GITHUB_PULL_REQUEST_URL = ::T.let(nil, ::T.untyped)
  GITLAB_MERGE_REQUEST_URL = ::T.let(nil, ::T.untyped)
end

class Bundler::EndpointSpecification
  include ::Bundler::MatchRemoteMetadata
  include ::Bundler::FetchMetadata
end

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def replace_with_backup(); end
end

class Bundler::EnvironmentPreserver
  def self.from_env(); end
end

module Bundler::FetchMetadata
  def matches_current_ruby?(); end

  def matches_current_rubygems?(); end
end

module Bundler::FetchMetadata
end

class Bundler::Fetcher
  def api_fetcher?(); end

  def fetch_spec(spec); end

  def gem_remote_fetcher(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationForbiddenError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::AuthenticationForbiddenError
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def gem_remote_fetcher(); end

  def initialize(downloader, remote, display_uri, gem_remote_fetcher); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end

  def self.ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
end

module Bundler::ForcePlatform
end

module Bundler::ForcePlatform
end

class Bundler::GemHelpers::PlatformMatch
  def self.specificity_score(spec_platform, user_platform); end
end

module Bundler::GemHelpers
  def self.force_ruby_platform(specs); end

  def self.generic_local_platform_is_ruby?(); end

  def self.local_platform(); end

  def self.same_deps(spec, exemplary_spec); end

  def self.same_specificity(platform, spec, exemplary_spec); end

  def self.sort_best_platform_match(matching, platform); end
end

class Bundler::GemVersionPromoter
  def filter_versions(package, specs); end

  def level(); end

  def level=(value); end

  def major?(); end

  def minor?(); end

  def pre(); end

  def pre=(pre); end

  def pre?(); end

  def sort_versions(package, specs); end

  def strict(); end

  def strict=(strict); end
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
  def add(spec); end

  def duplicates(); end

  def merge!(other); end

  def subset?(other); end
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::InsecureInstallPathError
  def initialize(path); end

  def status_code(); end
end

class Bundler::InsecureInstallPathError
end

class Bundler::Installer
  def definition(); end
end

class Bundler::LazySpecification
  include ::Bundler::ForcePlatform
  def dependencies=(dependencies); end

  def eql?(other); end

  def force_ruby_platform(); end

  def force_ruby_platform!(); end

  def force_ruby_platform=(force_ruby_platform); end

  def lock_name(); end

  def materialize_for_installation(); end

  def name_tuple(); end

  def required_ruby_version(); end

  def required_ruby_version=(required_ruby_version); end

  def required_rubygems_version(); end

  def required_rubygems_version=(required_rubygems_version); end

  def runtime_dependencies(); end
end

class Bundler::LazySpecification
  def self.from_spec(s); end
end

class Bundler::LockfileParser
  def checksums(); end

  def may_include_redundant_platform_specific_gems?(); end
  CHECKSUMS = ::T.let(nil, ::T.untyped)
end

class Bundler::LockfileParser::Position
  def advance!(string); end

  def column(); end

  def initialize(line, column); end

  def line(); end
end

class Bundler::LockfileParser::Position
end

class Bundler::LockfileParser
  def self.bundled_with(); end
end

module Bundler::MatchMetadata
  def matches_current_metadata?(); end

  def matches_current_ruby?(); end

  def matches_current_rubygems?(); end
end

module Bundler::MatchMetadata
end

module Bundler::MatchRemoteMetadata
  include ::Bundler::MatchMetadata
  include ::Bundler::FetchMetadata
end

module Bundler::MatchRemoteMetadata
end

class Bundler::PermissionError
  def parent_folder(); end

  def permission_type(); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def add_dependency_names(names); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def checksum_store(); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*arg); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def identifier(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def local!(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def spec_names(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_in_plugin_root?(name); end

  def installed_plugins(); end

  def plugin_commands(plugin); end

  def unregister_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Path
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Path
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.from_lock(locked_opts); end

  def self.list(); end

  def self.loaded?(plugin); end

  def self.save_plugin(name, spec, optional_plugin=T.unsafe(nil)); end

  def self.uninstall(names, options); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::PubGrub::Incompatibility
  def cause(); end

  def conflict?(); end

  def eql?(other); end

  def external_incompatibilities(); end

  def failure?(); end

  def initialize(terms, cause:, custom_explanation: T.unsafe(nil)); end

  def terms(); end
end

class Bundler::PubGrub::Incompatibility
end

class Bundler::RemoteSpecification
  include ::Bundler::MatchRemoteMetadata
  include ::Bundler::MatchMetadata
  include ::Bundler::FetchMetadata
  def runtime_dependencies(); end
end

class Bundler::Resolver
  include ::Bundler::GemHelpers
  def all_versions_for(package); end

  def bundler_pinned_to_current_version?(); end

  def default_bundler_source(); end

  def find_names_to_relax(incompatibility); end

  def incompatibilities_for(package, version); end

  def no_versions_incompatibility_for(package, unsatisfied_term); end

  def parse_dependency(package, dependency); end

  def raise_not_found!(package); end

  def setup_solver(); end

  def solve_versions(root:, logger:); end

  def source_for(name); end

  def versions_for(package, range=T.unsafe(nil)); end
end

class Bundler::Resolver::Base
  def [](name); end

  def base_requirements(); end

  def delete(specs); end

  def get_package(name); end

  def include_prereleases(names); end

  def initialize(source_requirements, dependencies, base, platforms, options); end

  def packages(); end

  def requirements(); end

  def source_requirements(); end

  def unlock_names(names); end
end

class Bundler::Resolver::Base
end

class Bundler::Resolver::Candidate
  include ::Comparable
  def ==(other); end

  def dependencies(); end

  def eql?(other); end

  def generic!(); end

  def initialize(version, specs: T.unsafe(nil)); end

  def platform_specific!(); end

  def prerelease?(); end

  def segments(); end

  def sort_obj(); end

  def to_specs(package); end

  def version(); end
end

class Bundler::Resolver::Candidate
end

class Bundler::Resolver::Incompatibility
  def extended_explanation(); end

  def initialize(terms, cause:, custom_explanation: T.unsafe(nil), extended_explanation: T.unsafe(nil)); end
end

class Bundler::Resolver::Incompatibility
end

class Bundler::Resolver::Package
  def ==(other); end

  def consider_prereleases!(); end

  def current_platform?(); end

  def dependency(); end

  def force_ruby_platform?(); end

  def ignores_prereleases?(); end

  def initialize(name, platforms, locked_specs:, unlock:, prerelease: T.unsafe(nil), dependency: T.unsafe(nil)); end

  def locked_version(); end

  def meta?(); end

  def name(); end

  def platforms(); end

  def prerelease_specified?(); end

  def root?(); end

  def top_level?(); end

  def unlock?(); end
end

class Bundler::Resolver::Package
end

class Bundler::Resolver::Root
  def initialize(name); end
end

class Bundler::Resolver::Root
end

class Bundler::Resolver::SpecGroup
  def dependencies(); end

  def empty?(); end

  def sorted_spec_names(); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

module Bundler::RubyDsl
  def normalize_ruby_file(filename); end
end

class Bundler::RubygemsIntegration
  def add_default_gems_to(specs); end

  def all_specs(); end

  def default_stubs(); end

  def find_bundler(version); end

  def find_name(name); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def supports_bundler_trampolining?(); end
end

module Bundler::SafeMarshal
  ALLOWED_CLASSES = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  PROC = ::T.let(nil, ::T.untyped)
end

module Bundler::SafeMarshal
end

class Bundler::SelfManager
  def install_locked_bundler_and_restart_with_it_if_needed(); end

  def restart_with_locked_bundler_if_needed(); end

  def update_bundler_and_restart_with_it_if_needed(target); end
end

class Bundler::SelfManager
end

class Bundler::Settings
  def processor_count(); end
  REMEMBERED_KEYS = ::T.let(nil, ::T.untyped)
  STRING_KEYS = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Path
  def self.keyword_init?(); end
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Settings
  def self.key_for(key); end

  def self.key_to_s(key); end
end

module Bundler::SharedHelpers
  def bundle_bin_path(); end

  def checksum_for_file(path, digest); end

  def relative_gemfile_path(); end

  def relative_lockfile_path(); end

  def relative_path_to(destination, from: T.unsafe(nil)); end
end

class Bundler::SolveFailure
  def status_code(); end
end

class Bundler::SolveFailure
end

class Bundler::Source
  def add_dependency_names(names); end

  def cached!(); end

  def checksum_store(); end

  def identifier(); end

  def local!(); end

  def local_only!(); end

  def remote!(); end

  def spec_names(); end
end

class Bundler::Source::Git
  def current_branch(); end

  def glob(); end

  def local?(); end

  def to_gemfile(); end

  def uri_with_specifiers(specifiers); end
end

class Bundler::Source::Rubygems
  def default_cache_path_for(dir); end

  def dependency_api_available?(); end

  def fetch_gem_if_possible(spec, previous_spec=T.unsafe(nil)); end

  def multiple_remotes?(); end

  def no_remotes?(); end

  def package_path(cache_path, spec); end

  def remote_fetchers(); end

  def remote_names(); end

  def remotes=(remotes); end

  def to_gemfile(); end
end

class Bundler::Source::RubygemsAggregate
  def identifier(); end

  def initialize(sources, source_map); end

  def source_map(); end

  def sources(); end

  def specs(); end
end

class Bundler::Source::RubygemsAggregate
end

class Bundler::SourceList
  def add_global_rubygems_remote(uri); end

  def aggregate_global_source?(); end

  def expired_sources?(replacement_sources); end

  def global_path_source(); end

  def implicit_global_source?(); end

  def local!(); end

  def local_mode?(); end

  def local_only!(); end

  def lock_other_sources(); end

  def lock_rubygems_sources(); end

  def merged_gem_lockfile_sections!(replacement_source); end

  def merged_gem_lockfile_sections?(); end

  def non_default_explicit_sources(); end

  def non_global_rubygems_sources(); end
end

class Bundler::SourceMap
  def all_requirements(); end

  def dependencies(); end

  def direct_requirements(); end

  def initialize(sources, dependencies, locked_specs); end

  def locked_requirements(); end

  def locked_specs(); end

  def pinned_spec_names(skip=T.unsafe(nil)); end

  def sources(); end
end

class Bundler::SourceMap
end

class Bundler::SpecSet
  include ::Enumerable
  include ::Bundler::TSort
  def -(other); end

  def add_extra_platforms!(platforms); end

  def complete_platforms!(platforms); end

  def delete(specs); end

  def delete_by_name(name); end

  def incomplete_for_platform?(deps, platform); end

  def incomplete_specs(); end

  def missing_specs(); end

  def names(); end

  def validate_deps(s); end
end

class Bundler::StubSpecification
  def checksum(); end

  def extensions(); end

  def full_gem_path=(path); end

  def gem_build_complete_path(); end

  def manually_installed?(); end
end

module Bundler::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::TSort::Cyclic
end

class Bundler::TSort::Cyclic
end

module Bundler::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  Correctable = ::T.let(nil, ::T.untyped)
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def content(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def replacement_present?(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def enum_to_s(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def print_default(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

class Bundler::Thor::AtLeastOneRequiredArgumentError
end

class Bundler::Thor::AtLeastOneRequiredArgumentError
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, wrap_long_description, usage, options=T.unsafe(nil), options_relation=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def method_at_least_one_option_names(); end

  def method_exclusive_option_names(); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def except(*keys); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def slice(*keys); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::ExclusiveArgumentError
end

class Bundler::Thor::ExclusiveArgumentError
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*arg); end

  def self.printable_tasks(*arg); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::Option
  def aliases(); end

  def aliases_for_usage(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_at_least_one!(); end

  def check_exclusive!(); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil), relations=T.unsafe(nil)); end

  def names_to_switch_names(names=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end

  def unshift(arg, is_value: T.unsafe(nil)); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_error(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  def self.at_least_one(*args, &block); end

  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.exclusive(*args, &block); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_at_least_one(*args, &block); end

  def self.method_at_least_one_option_names(); end

  def self.method_exclusive(*args, &block); end

  def self.method_exclusive_option_names(); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.print_at_least_one_required_options(shell, command=T.unsafe(nil)); end

  def self.print_exclusive_options(shell, command=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.sort_commands!(list); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def confirm?(); end

  def debug(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg=T.unsafe(nil), newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def error?(); end

  def info(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def info?(); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg=T.unsafe(nil), newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def warn?(); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

class Bundler::UI::Silent
  def confirm?(); end

  def error?(); end

  def info?(); end

  def warn?(); end
end

module Bundler::URINormalizer
end

module Bundler::URINormalizer
  def self.normalize_suffix(uri, trailing_slash: T.unsafe(nil)); end
end

module Bundler
  def self.auto_install(); end

  def self.configure_gem_home_and_path(path=T.unsafe(nil)); end

  def self.create_bundle_path(); end

  def self.gem_version(); end

  def self.most_specific_locked_platform?(platform); end

  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.preferred_gemfile_name(); end

  def self.reset_settings_and_root!(); end

  def self.safe_load_marshal(data); end

  def self.self_manager(); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end
end

class CGI
  VERSION = ::T.let(nil, ::T.untyped)
end

class CGI::Cookie
  DOMAIN_VALUE_RE = ::T.let(nil, ::T.untyped)
  PATH_VALUE_RE = ::T.let(nil, ::T.untyped)
  TOKEN_RE = ::T.let(nil, ::T.untyped)
end

module CGI::Escape
  def escapeURIComponent(arg); end

  def escape_uri_component(arg); end

  def unescapeURIComponent(*arg); end

  def unescape_uri_component(*arg); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

module CGI::Util
  def escapeURIComponent(arg); end

  def escape_uri_component(arg); end

  def unescapeURIComponent(*arg); end

  def unescape_uri_component(*arg); end
end

class Class
  def json_creatable?(); end
end

class Complex
  def to_d(*args); end
end

module Concurrent
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::FiberLocalVar
  LOCALS = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack
  EMPTY = ::T.let(nil, ::T.untyped)
end

Concurrent::LockLocalVar = Concurrent::FiberLocalVar

class Concurrent::MVar
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  NONE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_SYNCHRONOUS = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::SerializedExecutionDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Concurrent::SynchronizedDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Concurrent::ThreadLocalVar
  LOCALS = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  DEFAULT_INTERVAL_TYPE = ::T.let(nil, ::T.untyped)
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  FIXED_DELAY = ::T.let(nil, ::T.untyped)
  FIXED_RATE = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction
  ABORTED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

class ConnectionPool
  DEFAULTS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class ConnectionPool::Wrapper
  METHODS = ::T.let(nil, ::T.untyped)
end

module DRb
  VERSION = ::T.let(nil, ::T.untyped)
end

class DRb::DRbUNIXSocket
  def initialize(uri, soc, config=T.unsafe(nil), server_mode=T.unsafe(nil)); end
  Max_try = ::T.let(nil, ::T.untyped)
end

class DRb::DRbUNIXSocket
  def self.temp_server(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class Date
  def deconstruct_keys(arg); end

  def default_inspect(); end

  def infinite?(); end

  def readable_inspect(); end

  def to_fs(format=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class DateTime
  def self.new(*arg); end
end

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def detailed_message(highlight: T.unsafe(nil), did_you_mean: T.unsafe(nil), **arg); end

  def original_message(); end

  def spell_checker(); end
end

class DidYouMean::Formatter
  def message_for(corrections); end
end

class DidYouMean::Formatter
  def self.message_for(corrections); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*arg); end
end

class DidYouMean::PatternKeyNameChecker
  def corrections(); end

  def initialize(no_matching_pattern_key_error); end
end

class DidYouMean::PatternKeyNameChecker
end

DidYouMean::PlainFormatter = DidYouMean::Formatter

class DidYouMean::RequirePathChecker
  def corrections(); end

  def initialize(exception); end

  def path(); end
end

class DidYouMean::RequirePathChecker
  def self.requireables(); end
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dictionary_without_leaves(); end

  def dimensions(); end

  def find_leaves(path); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def plausible_dimensions(input); end

  def possible_paths(states); end

  def separator(); end

  def tree_depth(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end

  def self.spell_checkers(); end
end

module Digest
  VERSION = ::T.let(nil, ::T.untyped)
end

class Dir
  def chdir(); end

  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class Dir
  def self.fchdir(arg); end

  def self.for_fd(arg); end
end

class DummyEntity
  def self.inherited(s); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

module ERB::Escape
end

module ERB::Escape
  def self.html_escape(arg); end
end

module ERB::Util
  include ::ERB::Escape
  include ::ActiveSupport::CoreExt::ERBUtilPrivate
  include ::ActiveSupport::CoreExt::ERBUtil
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEXP = ::T.let(nil, ::T.untyped)
  INVALID_TAG_NAME_FOLLOWING_REGEXP = ::T.let(nil, ::T.untyped)
  INVALID_TAG_NAME_START_REGEXP = ::T.let(nil, ::T.untyped)
  SAFE_XML_TAG_NAME_REGEXP = ::T.let(nil, ::T.untyped)
  TAG_NAME_FOLLOWING_CODEPOINTS = ::T.let(nil, ::T.untyped)
  TAG_NAME_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
  TAG_NAME_START_CODEPOINTS = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  extend ::ActiveSupport::CoreExt::ERBUtil
  def self.html_escape_once(s); end

  def self.json_escape(s); end

  def self.tokenize(source); end

  def self.xml_name_escape(name); end
end

class Encoding
  def _dump(*arg); end
end

class Encoding::Converter
  def initialize(*arg); end
  LF_NEWLINE_DECORATOR = ::T.let(nil, ::T.untyped)
end

class Encoding
  def self._load(arg); end
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def as_json(options=T.unsafe(nil)); end

  def compact(); end
end

module Enumerable
  extend ::ActiveSupport::EnumerableCoreExt::Constants
end

class Enumerator
  def +(arg); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*arg); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Generator
  def each(*arg, &blk); end

  def initialize(*arg); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Enumerator::Product
  def each(&blk); end
end

class Enumerator::Product
end

class Enumerator
  def self.product(*arg); end
end

Errno::EAUTH = Errno::NOERROR

Errno::EBADARCH = Errno::NOERROR

Errno::EBADEXEC = Errno::NOERROR

Errno::EBADMACHO = Errno::NOERROR

Errno::EBADRPC = Errno::NOERROR

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::EDEADLK

Errno::EDEVERR = Errno::NOERROR

Errno::EDOOFUS = Errno::NOERROR

Errno::EFTYPE = Errno::NOERROR

Errno::EIPSEC = Errno::NOERROR

Errno::ELAST = Errno::NOERROR

Errno::ENEEDAUTH = Errno::NOERROR

Errno::ENOATTR = Errno::NOERROR

Errno::ENOPOLICY = Errno::NOERROR

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

Errno::EPROCLIM = Errno::NOERROR

Errno::EPROCUNAVAIL = Errno::NOERROR

Errno::EPROGMISMATCH = Errno::NOERROR

Errno::EPROGUNAVAIL = Errno::NOERROR

Errno::EPWROFF = Errno::NOERROR

Errno::EQFULL = Errno::NOERROR

Errno::ERPCMISMATCH = Errno::NOERROR

Errno::ESHLIBVERS = Errno::NOERROR

module ErrorHighlight::CoreExt
  def detailed_message(highlight: T.unsafe(nil), error_highlight: T.unsafe(nil), **arg); end
end

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid=(_); end

  def mem=(_); end

  def name=(_); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Etc::Passwd
  def dir=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ExitCalledError
end

class ExitCalledError
end

class Fiber
  def backtrace(*arg); end

  def backtrace_locations(*arg); end

  def blocking?(); end

  def initialize(*arg); end

  def kill(); end

  def storage(); end

  def storage=(storage); end

  def transfer(*arg); end
end

class Fiber
  def self.blocking(); end

  def self.blocking?(); end

  def self.current(); end

  def self.current_scheduler(); end

  def self.schedule(*arg); end

  def self.scheduler(); end

  def self.set_scheduler(arg); end
end

class File
  def self.absolute_path?(arg); end

  def self.atomic_write(file_name, temp_dir=T.unsafe(nil)); end

  def self.probe_stat_in(dir); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
  def self.ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.latest_compact_info(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
end

module Gem::BUNDLED_GEMS
  def self.build_message(gem); end

  def self.find_gem(path); end

  def self.replace_require(specs); end

  def self.warning?(name, specs: T.unsafe(nil)); end
end

class Gem::BasicSpecification
  def plugins(); end
end

module Gem::BetterPermissionError
  def data(); end
end

module Gem::BetterPermissionError
end

module Gem::CIDetector
  ENV_DESCRIPTORS = ::T.let(nil, ::T.untyped)
  ENV_INDICATORS = ::T.let(nil, ::T.untyped)
end

module Gem::CIDetector
  def self.ci?(); end

  def self.ci_strings(); end
end

class Gem::ConfigFile
  def ipv4_fallback_enabled(); end

  def ipv4_fallback_enabled=(ipv4_fallback_enabled); end

  def last_update_check(); end

  def last_update_check=(timestamp); end

  def state_file_name(); end

  def state_file_writable?(); end
  DEFAULT_IPV4_FALLBACK_ENABLED = ::T.let(nil, ::T.untyped)
end

class Gem::ConfigFile
  def self.dump_with_rubygems_yaml(content); end

  def self.load_with_rubygems_config_hash(yaml); end
end

class Gem::Dependency
  include ::Bundler::ForcePlatform
  def force_ruby_platform(); end
end

class Gem::DependencyList
  include ::Gem::TSort
end

module Gem::Deprecate
  def deprecate(name, repl, year, month); end
end

module Gem::Deprecate
  def self.next_rubygems_major_version(); end

  def self.rubygems_deprecate(name, replacement=T.unsafe(nil)); end

  def self.rubygems_deprecate_command(version=T.unsafe(nil)); end
end

class Gem::Installer
  include ::Gem::InstallerUninstallerUtils
  def ensure_writable_dir(dir); end

  def explicit_version_requirement(name); end

  def gemdeps_load(name); end

  def generate_plugins(); end
end

class Gem::Installer::ExtensionBuildError
end

class Gem::Installer::ExtensionBuildError
end

class Gem::Installer::FakePackage
  def copy_to(path); end

  def data_mode(); end

  def data_mode=(data_mode); end

  def dir_mode(); end

  def dir_mode=(dir_mode); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def initialize(spec); end

  def prog_mode(); end

  def prog_mode=(prog_mode); end

  def spec(); end

  def spec=(spec); end
end

class Gem::Installer::FakePackage
end

class Gem::Installer
  def self.inherited(klass); end
end

module Gem::InstallerUninstallerUtils
  def regenerate_plugins_for(spec, plugins_dir); end

  def remove_plugins_for(spec, plugins_dir); end
end

module Gem::InstallerUninstallerUtils
end

class Gem::Licenses
  DEPRECATED_EXCEPTION_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  DEPRECATED_EXCEPTION_REGEXP = ::T.let(nil, ::T.untyped)
  DEPRECATED_LICENSE_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  DEPRECATED_LICENSE_REGEXP = ::T.let(nil, ::T.untyped)
  LICENSE_REF = ::T.let(nil, ::T.untyped)
  VALID_REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::Licenses
  def self.deprecated_exception_id?(license); end

  def self.deprecated_license_id?(license); end
end

module Gem::Molinillo::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_equal?(dependencies, other_dependencies); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Molinillo::SpecificationProvider
end

module Gem::Molinillo::UI
  def after_resolution(); end

  def before_resolution(); end

  def debug(depth=T.unsafe(nil)); end

  def debug?(); end

  def indicate_progress(); end

  def output(); end

  def progress_rate(); end
end

module Gem::Molinillo::UI
end

class Gem::NameTuple
  def lock_name(); end
end

module Gem::Net
end

class Gem::Net::BufferedIO
  def <<(*strs); end

  def close(); end

  def closed?(); end

  def continue_timeout(); end

  def continue_timeout=(continue_timeout); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def eof?(); end

  def initialize(io, read_timeout: T.unsafe(nil), write_timeout: T.unsafe(nil), continue_timeout: T.unsafe(nil), debug_output: T.unsafe(nil)); end

  def io(); end

  def read(len, dest=T.unsafe(nil), ignore_eof=T.unsafe(nil)); end

  def read_all(dest=T.unsafe(nil)); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def readline(); end

  def readuntil(terminator, ignore_eof=T.unsafe(nil)); end

  def write(*strs); end

  def write_timeout(); end

  def write_timeout=(write_timeout); end

  def writeline(str); end
  BUFSIZE = ::T.let(nil, ::T.untyped)
end

class Gem::Net::BufferedIO
end

class Gem::Net::HTTP
  def active?(); end

  def address(); end

  def ca_file(); end

  def ca_file=(ca_file); end

  def ca_path(); end

  def ca_path=(ca_path); end

  def cert(); end

  def cert=(cert); end

  def cert_store(); end

  def cert_store=(cert_store); end

  def ciphers(); end

  def ciphers=(ciphers); end

  def close_on_empty_response(); end

  def close_on_empty_response=(close_on_empty_response); end

  def continue_timeout(); end

  def continue_timeout=(sec); end

  def copy(path, initheader=T.unsafe(nil)); end

  def delete(path, initheader=T.unsafe(nil)); end

  def extra_chain_cert(); end

  def extra_chain_cert=(extra_chain_cert); end

  def finish(); end

  def get(path, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def get2(path, initheader=T.unsafe(nil), &block); end

  def head(path, initheader=T.unsafe(nil)); end

  def head2(path, initheader=T.unsafe(nil), &block); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def initialize(address, port=T.unsafe(nil)); end

  def ipaddr(); end

  def ipaddr=(addr); end

  def keep_alive_timeout(); end

  def keep_alive_timeout=(keep_alive_timeout); end

  def key(); end

  def key=(key); end

  def local_host(); end

  def local_host=(local_host); end

  def local_port(); end

  def local_port=(local_port); end

  def lock(path, body, initheader=T.unsafe(nil)); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def mkcol(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  def move(path, initheader=T.unsafe(nil)); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def options(path, initheader=T.unsafe(nil)); end

  def patch(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def peer_cert(); end

  def port(); end

  def post(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def post2(path, data, initheader=T.unsafe(nil), &block); end

  def propfind(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  def proppatch(path, body, initheader=T.unsafe(nil)); end

  def proxy?(); end

  def proxy_address(); end

  def proxy_address=(proxy_address); end

  def proxy_from_env=(proxy_from_env); end

  def proxy_from_env?(); end

  def proxy_pass(); end

  def proxy_pass=(proxy_pass); end

  def proxy_port(); end

  def proxy_port=(proxy_port); end

  def proxy_uri(); end

  def proxy_user(); end

  def proxy_user=(proxy_user); end

  def proxyaddr(); end

  def proxyport(); end

  def put(path, data, initheader=T.unsafe(nil)); end

  def put2(path, data, initheader=T.unsafe(nil), &block); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def request(req, body=T.unsafe(nil), &block); end

  def request_get(path, initheader=T.unsafe(nil), &block); end

  def request_head(path, initheader=T.unsafe(nil), &block); end

  def request_post(path, data, initheader=T.unsafe(nil), &block); end

  def request_put(path, data, initheader=T.unsafe(nil), &block); end

  def response_body_encoding(); end

  def response_body_encoding=(value); end

  def send_request(name, path, data=T.unsafe(nil), header=T.unsafe(nil)); end

  def set_debug_output(output); end

  def ssl_timeout(); end

  def ssl_timeout=(ssl_timeout); end

  def ssl_version(); end

  def ssl_version=(ssl_version); end

  def start(); end

  def started?(); end

  def trace(path, initheader=T.unsafe(nil)); end

  def unlock(path, body, initheader=T.unsafe(nil)); end

  def use_ssl=(flag); end

  def use_ssl?(); end

  def verify_callback(); end

  def verify_callback=(verify_callback); end

  def verify_depth(); end

  def verify_depth=(verify_depth); end

  def verify_hostname(); end

  def verify_hostname=(verify_hostname); end

  def verify_mode(); end

  def verify_mode=(verify_mode); end

  def write_timeout(); end

  def write_timeout=(sec); end
  HAVE_ZLIB = ::T.let(nil, ::T.untyped)
  HTTPVersion = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS_ = ::T.let(nil, ::T.untyped)
  SSL_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SSL_IVNAMES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Copy
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Copy
end

class Gem::Net::HTTP::Delete
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Delete
end

class Gem::Net::HTTP::Get
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Get
end

class Gem::Net::HTTP::Head
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Head
end

class Gem::Net::HTTP::Lock
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Lock
end

class Gem::Net::HTTP::Mkcol
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Mkcol
end

class Gem::Net::HTTP::Move
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Move
end

class Gem::Net::HTTP::Options
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Options
end

class Gem::Net::HTTP::Patch
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Patch
end

class Gem::Net::HTTP::Persistent
  def ca_file(); end

  def ca_file=(file); end

  def ca_path(); end

  def ca_path=(path); end

  def cert(); end

  def cert=(certificate); end

  def cert_store(); end

  def cert_store=(store); end

  def certificate(); end

  def certificate=(certificate); end

  def ciphers(); end

  def ciphers=(ciphers); end

  def connection_for(uri); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def escape(str); end

  def expired?(connection); end

  def finish(connection); end

  def generation(); end

  def headers(); end

  def http_version(uri); end

  def http_versions(); end

  def idle_timeout(); end

  def idle_timeout=(idle_timeout); end

  def initialize(name: T.unsafe(nil), proxy: T.unsafe(nil), pool_size: T.unsafe(nil)); end

  def keep_alive(); end

  def keep_alive=(keep_alive); end

  def key(); end

  def key=(key); end

  def max_requests(); end

  def max_requests=(max_requests); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def name(); end

  def no_proxy(); end

  def normalize_uri(uri); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def override_headers(); end

  def pool(); end

  def private_key(); end

  def private_key=(key); end

  def proxy=(proxy); end

  def proxy_bypass?(host, port); end

  def proxy_from_env(); end

  def proxy_uri(); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def reconnect(); end

  def reconnect_ssl(); end

  def request(uri, req=T.unsafe(nil), &block); end

  def request_setup(req_or_uri); end

  def reset(connection); end

  def reuse_ssl_sessions(); end

  def reuse_ssl_sessions=(reuse_ssl_sessions); end

  def shutdown(); end

  def socket_options(); end

  def ssl(connection); end

  def ssl_generation(); end

  def ssl_timeout(); end

  def ssl_timeout=(ssl_timeout); end

  def ssl_version(); end

  def ssl_version=(ssl_version); end

  def start(http); end

  def timeout_key(); end

  def unescape(str); end

  def verify_callback(); end

  def verify_callback=(callback); end

  def verify_depth(); end

  def verify_depth=(verify_depth); end

  def verify_mode(); end

  def verify_mode=(verify_mode); end

  def write_timeout(); end

  def write_timeout=(write_timeout); end
  DEFAULT_POOL_SIZE = ::T.let(nil, ::T.untyped)
  EPOCH = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Persistent::Connection
  def close(); end

  def finish(); end

  def http(); end

  def http=(http); end

  def initialize(http_class, http_args, ssl_generation); end

  def last_use(); end

  def last_use=(last_use); end

  def requests(); end

  def requests=(requests); end

  def reset(); end

  def ressl(ssl_generation); end

  def ssl_generation(); end

  def ssl_generation=(ssl_generation); end
end

class Gem::Net::HTTP::Persistent::Connection
end

class Gem::Net::HTTP::Persistent::Error
end

class Gem::Net::HTTP::Persistent::Error
end

class Gem::Net::HTTP::Persistent::Pool
  def checkin(net_http_args); end

  def checkout(net_http_args); end

  def key(); end

  def shutdown(); end
end

class Gem::Net::HTTP::Persistent::Pool
end

class Gem::Net::HTTP::Persistent::TimedStackMulti
end

class Gem::Net::HTTP::Persistent::TimedStackMulti
  def self.hash_of_arrays(); end
end

class Gem::Net::HTTP::Persistent
  def self.detect_idle_timeout(uri, max=T.unsafe(nil)); end
end

class Gem::Net::HTTP::Post
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Post
end

class Gem::Net::HTTP::Propfind
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Propfind
end

class Gem::Net::HTTP::Proppatch
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Proppatch
end

module Gem::Net::HTTP::ProxyDelta
end

module Gem::Net::HTTP::ProxyDelta
end

Gem::Net::HTTP::ProxyMod = Gem::Net::HTTP::ProxyDelta

class Gem::Net::HTTP::Put
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Put
end

class Gem::Net::HTTP::Trace
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Trace
end

class Gem::Net::HTTP::Unlock
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Unlock
end

class Gem::Net::HTTP
  def self.Proxy(p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil)); end

  def self.default_port(); end

  def self.get(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.get_print(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.get_response(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil), &block); end

  def self.http_default_port(); end

  def self.https_default_port(); end

  def self.is_version_1_1?(); end

  def self.is_version_1_2?(); end

  def self.new(address, port=T.unsafe(nil), p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil), p_no_proxy=T.unsafe(nil)); end

  def self.newobj(*arg, **arg1); end

  def self.post(url, data, header=T.unsafe(nil)); end

  def self.post_form(url, params); end

  def self.proxy_address(); end

  def self.proxy_class?(); end

  def self.proxy_pass(); end

  def self.proxy_port(); end

  def self.proxy_user(); end

  def self.socket_type(); end

  def self.start(address, *arg, &block); end

  def self.version_1_1?(); end

  def self.version_1_2(); end

  def self.version_1_2?(); end
end

class Gem::Net::HTTPAccepted
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPAccepted
end

class Gem::Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPAlreadyReported
end

class Gem::Net::HTTPBadGateway
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPBadGateway
end

class Gem::Net::HTTPBadRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPBadRequest
end

class Gem::Net::HTTPBadResponse
end

class Gem::Net::HTTPBadResponse
end

class Gem::Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPClientError::EXCEPTION_TYPE = Gem::Net::HTTPClientException

class Gem::Net::HTTPClientError
end

Gem::Net::HTTPClientErrorCode = Gem::Net::HTTPClientError

class Gem::Net::HTTPClientException
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPClientException
end

class Gem::Net::HTTPConflict
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPConflict
end

class Gem::Net::HTTPContinue
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPContinue
end

class Gem::Net::HTTPCreated
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPCreated
end

class Gem::Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPEarlyHints
end

class Gem::Net::HTTPError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPError
end

module Gem::Net::HTTPExceptions
  def data(); end

  def initialize(msg, res); end

  def response(); end
end

module Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPExpectationFailed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPExpectationFailed
end

class Gem::Net::HTTPFailedDependency
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPFailedDependency
end

class Gem::Net::HTTPFatalError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPFatalError
end

Gem::Net::HTTPFatalErrorCode = Gem::Net::HTTPClientError

class Gem::Net::HTTPForbidden
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPForbidden
end

class Gem::Net::HTTPFound
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPFound
end

Gem::Net::HTTPGatewayTimeOut = Gem::Net::HTTPGatewayTimeout

class Gem::Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPGatewayTimeout
end

class Gem::Net::HTTPGenericRequest
  include ::Gem::Net::HTTPHeader
  def body(); end

  def body=(str); end

  def body_exist?(); end

  def body_stream(); end

  def body_stream=(input); end

  def decode_content(); end

  def exec(sock, ver, path); end

  def initialize(m, reqbody, resbody, uri_or_path, initheader=T.unsafe(nil)); end

  def method(); end

  def path(); end

  def request_body_permitted?(); end

  def response_body_permitted?(); end

  def set_body_internal(str); end

  def update_uri(addr, port, ssl); end

  def uri(); end
end

class Gem::Net::HTTPGenericRequest::Chunker
  def finish(); end

  def initialize(sock); end

  def write(buf); end
end

class Gem::Net::HTTPGenericRequest::Chunker
end

class Gem::Net::HTTPGenericRequest
end

class Gem::Net::HTTPGone
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPGone
end

module Gem::Net::HTTPHeader
  def [](key); end

  def []=(key, val); end

  def add_field(key, val); end

  def basic_auth(account, password); end

  def canonical_each(); end

  def chunked?(); end

  def connection_close?(); end

  def connection_keep_alive?(); end

  def content_length(); end

  def content_length=(len); end

  def content_range(); end

  def content_type(); end

  def content_type=(type, params=T.unsafe(nil)); end

  def delete(key); end

  def each(&blk); end

  def each_capitalized(); end

  def each_capitalized_name(); end

  def each_header(); end

  def each_key(&block); end

  def each_name(&block); end

  def each_value(); end

  def fetch(key, *args, &block); end

  def form_data=(params, sep=T.unsafe(nil)); end

  def get_fields(key); end

  def initialize_http_header(initheader); end

  def key?(key); end

  def length(); end

  def main_type(); end

  def proxy_basic_auth(account, password); end

  def range(); end

  def range=(r, e=T.unsafe(nil)); end

  def range_length(); end

  def set_content_type(type, params=T.unsafe(nil)); end

  def set_form(params, enctype=T.unsafe(nil), formopt=T.unsafe(nil)); end

  def set_form_data(params, sep=T.unsafe(nil)); end

  def set_range(r, e=T.unsafe(nil)); end

  def size(); end

  def sub_type(); end

  def to_hash(); end

  def type_params(); end
  MAX_FIELD_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_KEY_LENGTH = ::T.let(nil, ::T.untyped)
end

module Gem::Net::HTTPHeader
end

class Gem::Net::HTTPHeaderSyntaxError
end

class Gem::Net::HTTPHeaderSyntaxError
end

class Gem::Net::HTTPIMUsed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPIMUsed
end

class Gem::Net::HTTPInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPInformation::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPInformation
end

Gem::Net::HTTPInformationCode = Gem::Net::HTTPInformation

class Gem::Net::HTTPInsufficientStorage
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPInsufficientStorage
end

class Gem::Net::HTTPInternalServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPInternalServerError
end

class Gem::Net::HTTPLengthRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLengthRequired
end

class Gem::Net::HTTPLocked
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLocked
end

class Gem::Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLoopDetected
end

class Gem::Net::HTTPMethodNotAllowed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMethodNotAllowed
end

class Gem::Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMisdirectedRequest
end

class Gem::Net::HTTPMovedPermanently
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMovedPermanently
end

Gem::Net::HTTPMovedTemporarily = Gem::Net::HTTPFound

class Gem::Net::HTTPMultiStatus
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMultiStatus
end

Gem::Net::HTTPMultipleChoice = Gem::Net::HTTPMultipleChoices

class Gem::Net::HTTPMultipleChoices
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMultipleChoices
end

class Gem::Net::HTTPNetworkAuthenticationRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNetworkAuthenticationRequired
end

class Gem::Net::HTTPNoContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNoContent
end

class Gem::Net::HTTPNonAuthoritativeInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNonAuthoritativeInformation
end

class Gem::Net::HTTPNotAcceptable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotAcceptable
end

class Gem::Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotExtended
end

class Gem::Net::HTTPNotFound
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotFound
end

class Gem::Net::HTTPNotImplemented
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotImplemented
end

class Gem::Net::HTTPNotModified
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotModified
end

class Gem::Net::HTTPOK
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPOK
end

class Gem::Net::HTTPPartialContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPartialContent
end

class Gem::Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPayloadTooLarge
end

class Gem::Net::HTTPPaymentRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPaymentRequired
end

class Gem::Net::HTTPPermanentRedirect
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPermanentRedirect
end

class Gem::Net::HTTPPreconditionFailed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPreconditionFailed
end

class Gem::Net::HTTPPreconditionRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPreconditionRequired
end

class Gem::Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPProcessing
end

class Gem::Net::HTTPProxyAuthenticationRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPProxyAuthenticationRequired
end

class Gem::Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRangeNotSatisfiable
end

class Gem::Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRedirection
end

Gem::Net::HTTPRedirectionCode = Gem::Net::HTTPRedirection

class Gem::Net::HTTPRequest
  def initialize(path, initheader=T.unsafe(nil)); end
end

class Gem::Net::HTTPRequest
end

Gem::Net::HTTPRequestEntityTooLarge = Gem::Net::HTTPPayloadTooLarge

class Gem::Net::HTTPRequestHeaderFieldsTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRequestHeaderFieldsTooLarge
end

Gem::Net::HTTPRequestTimeOut = Gem::Net::HTTPRequestTimeout

class Gem::Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRequestTimeout
end

Gem::Net::HTTPRequestURITooLarge = Gem::Net::HTTPURITooLong

Gem::Net::HTTPRequestURITooLong = Gem::Net::HTTPURITooLong

Gem::Net::HTTPRequestedRangeNotSatisfiable = Gem::Net::HTTPRangeNotSatisfiable

class Gem::Net::HTTPResetContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPResetContent
end

Gem::Net::HTTPResponceReceiver = Gem::Net::HTTPResponse

class Gem::Net::HTTPResponse
  include ::Gem::Net::HTTPHeader
  def body(); end

  def body=(value); end

  def body_encoding(); end

  def body_encoding=(value); end

  def code(); end

  def code_type(); end

  def decode_content(); end

  def decode_content=(decode_content); end

  def entity(); end

  def error!(); end

  def error_type(); end

  def header(); end

  def http_version(); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def initialize(httpv, code, msg); end

  def message(); end

  def msg(); end

  def read_body(dest=T.unsafe(nil), &block); end

  def read_header(); end

  def reading_body(sock, reqmethodallowbody); end

  def response(); end

  def uri(); end

  def uri=(uri); end

  def value(); end
  CODE_CLASS_TO_OBJ = ::T.let(nil, ::T.untyped)
  CODE_TO_OBJ = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPResponse::Inflater
  def bytes_inflated(); end

  def finish(); end

  def inflate_adapter(dest); end

  def initialize(socket); end

  def read(clen, dest, ignore_eof=T.unsafe(nil)); end

  def read_all(dest); end
end

class Gem::Net::HTTPResponse::Inflater
end

class Gem::Net::HTTPResponse
  def self.body_permitted?(); end

  def self.exception_type(); end

  def self.read_new(sock); end
end

Gem::Net::HTTPResponseReceiver = Gem::Net::HTTPResponse

Gem::Net::HTTPRetriableCode = Gem::Net::HTTPRedirection

class Gem::Net::HTTPRetriableError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPRetriableError
end

class Gem::Net::HTTPSeeOther
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPSeeOther
end

class Gem::Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPServerError::EXCEPTION_TYPE = Gem::Net::HTTPFatalError

class Gem::Net::HTTPServerError
end

Gem::Net::HTTPServerErrorCode = Gem::Net::HTTPServerError

Gem::Net::HTTPServerException = Gem::Net::HTTPClientException

class Gem::Net::HTTPServiceUnavailable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPServiceUnavailable
end

Gem::Net::HTTPSession = Gem::Net::HTTP

class Gem::Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPSuccess::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPSuccess
end

Gem::Net::HTTPSuccessCode = Gem::Net::HTTPSuccess

class Gem::Net::HTTPSwitchProtocol
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPSwitchProtocol
end

class Gem::Net::HTTPTemporaryRedirect
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPTemporaryRedirect
end

class Gem::Net::HTTPTooManyRequests
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPTooManyRequests
end

class Gem::Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPURITooLong
end

class Gem::Net::HTTPUnauthorized
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnauthorized
end

class Gem::Net::HTTPUnavailableForLegalReasons
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnavailableForLegalReasons
end

class Gem::Net::HTTPUnknownResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPUnknownResponse::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPUnknownResponse
end

class Gem::Net::HTTPUnprocessableEntity
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnprocessableEntity
end

class Gem::Net::HTTPUnsupportedMediaType
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnsupportedMediaType
end

class Gem::Net::HTTPUpgradeRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUpgradeRequired
end

class Gem::Net::HTTPUseProxy
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUseProxy
end

class Gem::Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPVariantAlsoNegotiates
end

class Gem::Net::HTTPVersionNotSupported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPVersionNotSupported
end

class Gem::Net::InternetMessageIO
  def each_list_item(); end

  def each_message_chunk(); end

  def initialize(*arg, **arg1); end

  def write_message(src); end

  def write_message_0(src); end

  def write_message_by_block(&block); end
end

class Gem::Net::InternetMessageIO
end

module Gem::Net::NetPrivate
end

Gem::Net::NetPrivate::HTTPRequest = Gem::Net::HTTPRequest

Gem::Net::NetPrivate::Socket = Gem::Net::InternetMessageIO

module Gem::Net::NetPrivate
end

class Gem::Net::OpenTimeout
end

class Gem::Net::OpenTimeout
end

class Gem::Net::ProtoAuthError
end

class Gem::Net::ProtoAuthError
end

class Gem::Net::ProtoCommandError
end

class Gem::Net::ProtoCommandError
end

class Gem::Net::ProtoFatalError
end

class Gem::Net::ProtoFatalError
end

class Gem::Net::ProtoRetriableError
end

class Gem::Net::ProtoRetriableError
end

class Gem::Net::ProtoServerError
end

class Gem::Net::ProtoServerError
end

class Gem::Net::ProtoSyntaxError
end

class Gem::Net::ProtoSyntaxError
end

class Gem::Net::ProtoUnknownError
end

class Gem::Net::ProtoUnknownError
end

Gem::Net::ProtocRetryError = Gem::Net::ProtoRetriableError

class Gem::Net::Protocol
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::Protocol
  def self.protocol_param(name, val); end
end

class Gem::Net::ProtocolError
end

class Gem::Net::ProtocolError
end

class Gem::Net::ReadAdapter
  def <<(str); end

  def initialize(block); end
end

class Gem::Net::ReadAdapter
end

class Gem::Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Gem::Net::ReadTimeout
end

class Gem::Net::WriteAdapter
  def <<(str); end

  def initialize(writer); end

  def print(str); end

  def printf(*args); end

  def puts(str=T.unsafe(nil)); end

  def write(str); end
end

class Gem::Net::WriteAdapter
end

class Gem::Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Gem::Net::WriteTimeout
end

module Gem::Net
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Platform
  def normalized_linux_version(); end

  def normalized_linux_version_ext(); end
  WINDOWS = ::T.let(nil, ::T.untyped)
  X64_LINUX = ::T.let(nil, ::T.untyped)
  X64_LINUX_MUSL = ::T.let(nil, ::T.untyped)
end

class Gem::Platform
  def self._deprecated_match(platform); end

  def self.match_gem?(platform, gem_name); end

  def self.match_spec?(spec); end

  def self.sort_priority(platform); end
end

class Gem::RequestSet
  include ::Gem::TSort
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def self.keyword_init?(); end
end

class Gem::Requirement
  def _sorted_requirements(); end
end

class Gem::Resolv
  def each_address(name); end

  def each_name(address); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def initialize(resolvers=T.unsafe(nil), use_ipv6: T.unsafe(nil)); end
  AddressRegex = ::T.let(nil, ::T.untyped)
  DefaultResolver = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS
  def close(); end

  def each_address(name); end

  def each_name(address); end

  def each_resource(name, typeclass, &proc); end

  def extract_resources(msg, name, typeclass); end

  def fetch_resource(name, typeclass); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def getresource(name, typeclass); end

  def getresources(name, typeclass); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def make_tcp_requester(host, port); end

  def make_udp_requester(); end

  def timeouts=(values); end
  Port = ::T.let(nil, ::T.untyped)
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
  UDPSize = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Config
  def generate_candidates(name); end

  def generate_timeouts(); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def nameserver_port(); end

  def resolv(name); end

  def single?(); end

  def timeouts=(values); end

  def use_ipv6?(); end
  InitialTimeout = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Config::NXDomain
end

class Gem::Resolv::DNS::Config::NXDomain
end

class Gem::Resolv::DNS::Config::OtherResolvError
end

class Gem::Resolv::DNS::Config::OtherResolvError
end

class Gem::Resolv::DNS::Config
  def self.default_config_hash(filename=T.unsafe(nil)); end

  def self.parse_resolv_conf(filename); end
end

class Gem::Resolv::DNS::DecodeError
end

class Gem::Resolv::DNS::DecodeError
end

class Gem::Resolv::DNS::EncodeError
end

class Gem::Resolv::DNS::EncodeError
end

module Gem::Resolv::DNS::Label
end

class Gem::Resolv::DNS::Label::Str
  def ==(other); end

  def downcase(); end

  def eql?(other); end

  def initialize(string); end

  def string(); end
end

class Gem::Resolv::DNS::Label::Str
end

module Gem::Resolv::DNS::Label
  def self.split(arg); end
end

class Gem::Resolv::DNS::Message
  def ==(other); end

  def aa(); end

  def aa=(aa); end

  def add_additional(name, ttl, data); end

  def add_answer(name, ttl, data); end

  def add_authority(name, ttl, data); end

  def add_question(name, typeclass); end

  def additional(); end

  def answer(); end

  def authority(); end

  def each_additional(); end

  def each_answer(); end

  def each_authority(); end

  def each_question(); end

  def each_resource(); end

  def encode(); end

  def id(); end

  def id=(id); end

  def initialize(id=T.unsafe(nil)); end

  def opcode(); end

  def opcode=(opcode); end

  def qr(); end

  def qr=(qr); end

  def question(); end

  def ra(); end

  def ra=(ra); end

  def rcode(); end

  def rcode=(rcode); end

  def rd(); end

  def rd=(rd); end

  def tc(); end

  def tc=(tc); end
end

class Gem::Resolv::DNS::Message::MessageDecoder
  def get_bytes(len=T.unsafe(nil)); end

  def get_label(); end

  def get_labels(); end

  def get_length16(); end

  def get_list(); end

  def get_name(); end

  def get_question(); end

  def get_rr(); end

  def get_string(); end

  def get_string_list(); end

  def get_unpack(template); end

  def initialize(data); end
end

class Gem::Resolv::DNS::Message::MessageDecoder
end

class Gem::Resolv::DNS::Message::MessageEncoder
  def put_bytes(d); end

  def put_label(d); end

  def put_labels(d, compress: T.unsafe(nil)); end

  def put_length16(); end

  def put_name(d, compress: T.unsafe(nil)); end

  def put_pack(template, *d); end

  def put_string(d); end

  def put_string_list(ds); end
end

class Gem::Resolv::DNS::Message::MessageEncoder
end

class Gem::Resolv::DNS::Message
  def self.decode(m); end
end

class Gem::Resolv::DNS::Name
  def ==(other); end

  def [](i); end

  def absolute?(); end

  def eql?(other); end

  def initialize(labels, absolute=T.unsafe(nil)); end

  def length(); end

  def subdomain_of?(other); end

  def to_a(); end
end

class Gem::Resolv::DNS::Name
  def self.create(arg); end
end

module Gem::Resolv::DNS::OpCode
  IQuery = ::T.let(nil, ::T.untyped)
  Notify = ::T.let(nil, ::T.untyped)
  Query = ::T.let(nil, ::T.untyped)
  Status = ::T.let(nil, ::T.untyped)
  Update = ::T.let(nil, ::T.untyped)
end

module Gem::Resolv::DNS::OpCode
end

class Gem::Resolv::DNS::Query
  def encode_rdata(msg); end
end

class Gem::Resolv::DNS::Query
  def self.decode_rdata(msg); end
end

module Gem::Resolv::DNS::RCode
  BADALG = ::T.let(nil, ::T.untyped)
  BADKEY = ::T.let(nil, ::T.untyped)
  BADMODE = ::T.let(nil, ::T.untyped)
  BADNAME = ::T.let(nil, ::T.untyped)
  BADSIG = ::T.let(nil, ::T.untyped)
  BADTIME = ::T.let(nil, ::T.untyped)
  BADVERS = ::T.let(nil, ::T.untyped)
  FormErr = ::T.let(nil, ::T.untyped)
  NXDomain = ::T.let(nil, ::T.untyped)
  NXRRSet = ::T.let(nil, ::T.untyped)
  NoError = ::T.let(nil, ::T.untyped)
  NotAuth = ::T.let(nil, ::T.untyped)
  NotImp = ::T.let(nil, ::T.untyped)
  NotZone = ::T.let(nil, ::T.untyped)
  Refused = ::T.let(nil, ::T.untyped)
  ServFail = ::T.let(nil, ::T.untyped)
  YXDomain = ::T.let(nil, ::T.untyped)
  YXRRSet = ::T.let(nil, ::T.untyped)
end

module Gem::Resolv::DNS::RCode
end

class Gem::Resolv::DNS::Requester
  def close(); end

  def request(sender, tout); end

  def sender_for(addr, msg); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP::Sender
  def data(); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP::Sender
end

class Gem::Resolv::DNS::Requester::ConnectedUDP
end

class Gem::Resolv::DNS::Requester::MDNSOneShot
end

class Gem::Resolv::DNS::Requester::MDNSOneShot
end

class Gem::Resolv::DNS::Requester::RequestError
end

class Gem::Resolv::DNS::Requester::RequestError
end

class Gem::Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Gem::Resolv::DNS::Requester::Sender
end

class Gem::Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::TCP::Sender
  def data(); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::TCP::Sender
end

class Gem::Resolv::DNS::Requester::TCP
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host, port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP::Sender
  def data(); end

  def initialize(msg, data, sock, host, port); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP::Sender
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP
end

class Gem::Resolv::DNS::Requester
end

class Gem::Resolv::DNS::Resource
  def ==(other); end

  def eql?(other); end

  def ttl(); end
  ClassHash = ::T.let(nil, ::T.untyped)
  ClassInsensitiveTypes = ::T.let(nil, ::T.untyped)
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::ANY
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::ANY
end

class Gem::Resolv::DNS::Resource::CNAME
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::CNAME
end

class Gem::Resolv::DNS::Resource::DomainName
  def initialize(name); end

  def name(); end
end

class Gem::Resolv::DNS::Resource::DomainName
end

class Gem::Resolv::DNS::Resource::Generic
  def data(); end

  def initialize(data); end
end

class Gem::Resolv::DNS::Resource::Generic
  def self.create(type_value, class_value); end
end

class Gem::Resolv::DNS::Resource::HINFO
  def cpu(); end

  def initialize(cpu, os); end

  def os(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::HINFO
end

module Gem::Resolv::DNS::Resource::IN
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::A
  def address(); end

  def initialize(address); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::A
end

class Gem::Resolv::DNS::Resource::IN::AAAA
  def address(); end

  def initialize(address); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::AAAA
end

class Gem::Resolv::DNS::Resource::IN::ANY
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::ANY
end

class Gem::Resolv::DNS::Resource::IN::CNAME
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::CNAME
end

class Gem::Resolv::DNS::Resource::IN::HINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::HINFO
end

class Gem::Resolv::DNS::Resource::IN::HTTPS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::HTTPS
end

class Gem::Resolv::DNS::Resource::IN::LOC
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::LOC
end

class Gem::Resolv::DNS::Resource::IN::MINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::MINFO
end

class Gem::Resolv::DNS::Resource::IN::MX
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::MX
end

class Gem::Resolv::DNS::Resource::IN::NS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::NS
end

class Gem::Resolv::DNS::Resource::IN::PTR
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::PTR
end

class Gem::Resolv::DNS::Resource::IN::SOA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SOA
end

class Gem::Resolv::DNS::Resource::IN::SRV
  def initialize(priority, weight, port, target); end

  def port(); end

  def priority(); end

  def target(); end

  def weight(); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SRV
end

class Gem::Resolv::DNS::Resource::IN::SVCB
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SVCB
end

class Gem::Resolv::DNS::Resource::IN::ServiceBinding
  def alias_mode?(); end

  def encode_rdata(msg); end

  def initialize(priority, target, params=T.unsafe(nil)); end

  def params(); end

  def priority(); end

  def service_mode?(); end

  def target(); end
end

class Gem::Resolv::DNS::Resource::IN::ServiceBinding
  def self.decode_rdata(msg); end
end

class Gem::Resolv::DNS::Resource::IN::TXT
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::TXT
end

class Gem::Resolv::DNS::Resource::IN::WKS
  def address(); end

  def bitmap(); end

  def initialize(address, protocol, bitmap); end

  def protocol(); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::WKS
end

module Gem::Resolv::DNS::Resource::IN
end

class Gem::Resolv::DNS::Resource::LOC
  def altitude(); end

  def hprecision(); end

  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end

  def latitude(); end

  def longitude(); end

  def ssize(); end

  def version(); end

  def vprecision(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::LOC
end

class Gem::Resolv::DNS::Resource::MINFO
  def emailbx(); end

  def initialize(rmailbx, emailbx); end

  def rmailbx(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::MINFO
end

class Gem::Resolv::DNS::Resource::MX
  def exchange(); end

  def initialize(preference, exchange); end

  def preference(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::MX
end

class Gem::Resolv::DNS::Resource::NS
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::NS
end

class Gem::Resolv::DNS::Resource::PTR
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::PTR
end

class Gem::Resolv::DNS::Resource::SOA
  def expire(); end

  def initialize(mname, rname, serial, refresh, retry_, expire, minimum); end

  def minimum(); end

  def mname(); end

  def refresh(); end

  def retry(); end

  def rname(); end

  def serial(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::SOA
end

class Gem::Resolv::DNS::Resource::TXT
  def data(); end

  def initialize(first_string, *rest_strings); end

  def strings(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::TXT
end

class Gem::Resolv::DNS::Resource
  def self.get_class(type_value, class_value); end
end

class Gem::Resolv::DNS::SvcParam
  ClassHash = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::ALPN
  def encode(msg); end

  def initialize(protocol_ids); end

  def protocol_ids(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::ALPN
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::DoHPath
  def encode(msg); end

  def initialize(template); end

  def template(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::DoHPath
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Generic
  def encode(msg); end

  def initialize(value); end

  def value(); end
end

class Gem::Resolv::DNS::SvcParam::Generic
  def self.create(key_number); end

  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::IPv4Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::IPv4Hint
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::IPv6Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::IPv6Hint
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Mandatory
  def encode(msg); end

  def initialize(keys); end

  def keys(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::Mandatory
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::NoDefaultALPN
  def encode(msg); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::NoDefaultALPN
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Port
  def encode(msg); end

  def initialize(port); end

  def port(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::Port
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam
  def self.key_name(); end

  def self.key_number(); end
end

class Gem::Resolv::DNS::SvcParams
  include ::Enumerable
  def [](key); end

  def add(param); end

  def count(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def encode(msg); end

  def initialize(params=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::SvcParams
  def self.decode(msg); end
end

class Gem::Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.open(*args); end

  def self.random(arg); end
end

class Gem::Resolv::Hosts
  def each_address(name, &proc); end

  def each_name(address, &proc); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def initialize(filename=T.unsafe(nil)); end

  def lazy_initialize(); end
  DefaultFileName = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::Hosts
end

class Gem::Resolv::IPv4
  def ==(other); end

  def address(); end

  def eql?(other); end

  def initialize(address); end

  def to_name(); end
  Regex = ::T.let(nil, ::T.untyped)
  Regex256 = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::IPv4
  def self.create(arg); end
end

class Gem::Resolv::IPv6
  def ==(other); end

  def address(); end

  def eql?(other); end

  def initialize(address); end

  def to_name(); end
  Regex = ::T.let(nil, ::T.untyped)
  Regex_6Hex4Dec = ::T.let(nil, ::T.untyped)
  Regex_8Hex = ::T.let(nil, ::T.untyped)
  Regex_8HexLinkLocal = ::T.let(nil, ::T.untyped)
  Regex_CompressedHex = ::T.let(nil, ::T.untyped)
  Regex_CompressedHex4Dec = ::T.let(nil, ::T.untyped)
  Regex_CompressedHexLinkLocal = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::IPv6
  def self.create(arg); end
end

module Gem::Resolv::LOC
end

class Gem::Resolv::LOC::Alt
  def ==(other); end

  def altitude(); end

  def eql?(other); end

  def initialize(altitude); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Alt
  def self.create(arg); end
end

class Gem::Resolv::LOC::Coord
  def ==(other); end

  def coordinates(); end

  def eql?(other); end

  def initialize(coordinates, orientation); end

  def orientation(); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Coord
  def self.create(arg); end
end

class Gem::Resolv::LOC::Size
  def ==(other); end

  def eql?(other); end

  def initialize(scalar); end

  def scalar(); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Size
  def self.create(arg); end
end

module Gem::Resolv::LOC
end

class Gem::Resolv::MDNS
  AddressV4 = ::T.let(nil, ::T.untyped)
  AddressV6 = ::T.let(nil, ::T.untyped)
  Addresses = ::T.let(nil, ::T.untyped)
  Port = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::MDNS
end

class Gem::Resolv::ResolvError
end

class Gem::Resolv::ResolvError
end

class Gem::Resolv::ResolvTimeout
end

class Gem::Resolv::ResolvTimeout
end

class Gem::Resolv
  def self.each_address(name, &block); end

  def self.each_name(address, &proc); end

  def self.getaddress(name); end

  def self.getaddresses(name); end

  def self.getname(address); end

  def self.getnames(address); end
end

class Gem::Resolver
  include ::Gem::Molinillo::UI
  include ::Gem::Molinillo::SpecificationProvider
end

class Gem::Resolver::APISet::GemParser
  def parse(line); end
end

class Gem::Resolver::APISet::GemParser
end

class Gem::Resolver::APISpecification
  def self.new(set, api_data); end
end

class Gem::Resolver::ActivationRequest
  def eql?(other); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::IndexSpecification
  def ==(other); end
end

class Gem::Resolver::InstallerSet
  def force(); end

  def force=(force); end
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Specification
  def required_ruby_version(); end

  def required_rubygems_version(); end
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil), num_results=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchMetadata
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def _deprecated_validate_dependencies(); end

  def _deprecated_validate_metadata(); end

  def _deprecated_validate_permissions(); end

  def deleted_gem?(); end

  def flatten_require_paths(); end

  def removed_method_calls(); end

  def to_ruby(); end
  LATEST_RUBY_WITHOUT_PATCH_VERSIONS = ::T.let(nil, ::T.untyped)
  REMOVED_METHODS = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.add_spec(spec); end

  def self.find_by_full_name(full_name); end

  def self.gemspec_stubs_in(dir, pattern); end

  def self.latest_spec_for(name); end

  def self.remove_spec(spec); end

  def self.specification_record(); end

  def self.stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_duplicate_dependencies(); end

  def validate_metadata(); end

  def validate_optional(strict); end

  def validate_permissions(); end

  def validate_required!(); end

  def validate_required_ruby_version(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::SpecificationRecord
  include ::Enumerable
  def add_spec(spec); end

  def all(); end

  def all=(specs); end

  def all_names(); end

  def each(&blk); end

  def find_active_stub_by_path(path); end

  def find_all_by_name(name, *requirements); end

  def find_by_path(path); end

  def find_inactive_by_path(path); end

  def initialize(dirs); end

  def latest_spec_for(name); end

  def latest_specs(prerelease); end

  def remove_spec(spec); end

  def stubs(); end

  def stubs_for(name); end

  def stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationRecord
  def self.dirs_from(paths); end

  def self.from_path(path); end
end

class Gem::StubSpecification
  include ::Gem::BetterPermissionError
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def spec(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

module Gem::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Gem::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

module Gem::Timeout
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Timeout::Error
end

class Gem::Timeout::Error
  def self.handle_timeout(message); end
end

class Gem::Timeout::ExitException
  def exception(*arg); end
end

class Gem::Timeout::ExitException
end

module Gem::Timeout
  def self.ensure_timeout_thread_created(); end

  def self.timeout(sec, klass=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

module Gem::URI
  include ::Gem::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCURICOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Gem::URI::BadURIError
end

class Gem::URI::BadURIError
end

class Gem::URI::Error
end

class Gem::URI::Error
end

class Gem::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Gem::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Gem::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::File
end

class Gem::URI::Generic
  include ::Gem::URI
  include ::Gem::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def decoded_password(); end

  def decoded_user(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def to_str(); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Gem::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Gem::URI::HTTP
  def authority(); end

  def origin(); end

  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::HTTP
end

class Gem::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::HTTPS
end

class Gem::URI::InvalidComponentError
end

class Gem::URI::InvalidComponentError
end

class Gem::URI::InvalidURIError
end

class Gem::URI::InvalidURIError
end

class Gem::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Gem::URI::LDAP
end

class Gem::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::LDAPS
end

class Gem::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::URI::MailTo
end

Gem::URI::Parser = Gem::URI::RFC2396_Parser

Gem::URI::REGEXP = Gem::URI::RFC2396_REGEXP

class Gem::URI::RFC2396_Parser
  include ::Gem::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Gem::URI::RFC2396_Parser
end

module Gem::URI::RFC2396_REGEXP
end

module Gem::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Gem::URI::RFC2396_REGEXP::PATTERN
end

module Gem::URI::RFC2396_REGEXP
end

class Gem::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SEG = ::T.let(nil, ::T.untyped)
  SEG_NC = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
end

class Gem::URI::RFC3986_Parser
end

module Gem::URI::Util
end

module Gem::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

class Gem::URI::WS
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::WS
end

class Gem::URI::WSS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::WSS
end

module Gem::URI
  def self.decode_uri_component(str, enc=T.unsafe(nil)); end

  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_uri_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.register_scheme(scheme, klass); end

  def self.scheme_list(); end

  def self.split(uri); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

class Gem::UnknownCommandError
  def initialize(unknown_command); end

  def unknown_command(); end
end

class Gem::UnknownCommandError
  def self.attach_correctable(); end
end

class Gem::UnknownCommandSpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end
end

class Gem::UnknownCommandSpellChecker
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

module Gem::Util
  def self._deprecated_silent_system(*command); end
end

class Gem::Version
  def partition_segments(ver); end
end

Gem::Version::Requirement = Gem::Requirement

class Gem::WebauthnVerificationError
  def initialize(message); end
end

class Gem::WebauthnVerificationError
end

module Gem
  def self.activated_gem_paths(); end

  def self.cache_home(); end

  def self.config_home(); end

  def self.data_home(); end

  def self.default_user_install(); end

  def self.disable_system_update_message(); end

  def self.disable_system_update_message=(disable_system_update_message); end

  def self.discover_gems_on_require(); end

  def self.discover_gems_on_require=(discover_gems_on_require); end

  def self.dynamic_library_suffixes(); end

  def self.find_config_file(); end

  def self.find_default_spec(path); end

  def self.freebsd_platform?(); end

  def self.load_safe_marshal(); end

  def self.open_file(path, flags, &block); end

  def self.plugin_suffix_pattern(); end

  def self.plugin_suffix_regexp(); end

  def self.plugindir(install_dir=T.unsafe(nil)); end

  def self.solaris_platform?(); end

  def self.state_file(); end

  def self.state_home(); end
end

class Hash
  def deconstruct_keys(arg); end
end

class Hash
  def self.ruby2_keywords_hash(arg); end

  def self.ruby2_keywords_hash?(arg); end
end

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

module I18n::Backend::KeyValue::Implementation
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

class I18n::Backend::LazyLoadable
  def initialize(lazy_load: T.unsafe(nil)); end

  def initialized_locales(); end
end

class I18n::Backend::LazyLoadable::FilenameIncorrect
  def initialize(file, expected_locale, unexpected_locales); end
end

class I18n::Backend::LazyLoadable::FilenameIncorrect
end

class I18n::Backend::LazyLoadable
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
end

class I18n::Backend::Simple
  include ::I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def eager_load!(); end

  def init_translations(); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translations(do_init: T.unsafe(nil)); end
  MUTEX = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Simple::Implementation
end

class I18n::Backend::Simple
end

module I18n::Backend::Transliterator
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
end

class I18n::InvalidFilenames
  NUMBER_OF_ERRORS_SHOWN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

module I18n::MissingTranslation::Base
  PERMITTED_KEYS = ::T.let(nil, ::T.untyped)
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n::Tests
end

class IO
  def nonblock(*arg); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def path(); end

  def pathconf(arg); end

  def ready?(); end

  def timeout(); end

  def timeout=(timeout); end

  def to_path(); end

  def wait(*arg); end

  def wait_priority(*arg); end

  def wait_readable(*arg); end

  def wait_writable(*arg); end
  PRIORITY = ::T.let(nil, ::T.untyped)
  READABLE = ::T.let(nil, ::T.untyped)
  WRITABLE = ::T.let(nil, ::T.untyped)
end

class IO::Buffer
  include ::Comparable
  def &(arg); end

  def ^(arg); end

  def and!(arg); end

  def clear(*arg); end

  def copy(*arg); end

  def each(*arg, &blk); end

  def each_byte(*arg); end

  def empty?(); end

  def external?(); end

  def free(); end

  def get_string(*arg); end

  def get_value(arg, arg1); end

  def get_values(arg, arg1); end

  def hexdump(*arg); end

  def initialize(*arg); end

  def internal?(); end

  def locked(); end

  def locked?(); end

  def mapped?(); end

  def not!(); end

  def null?(); end

  def or!(arg); end

  def pread(*arg); end

  def private?(); end

  def pwrite(*arg); end

  def read(*arg); end

  def readonly?(); end

  def resize(arg); end

  def set_string(*arg); end

  def set_value(arg, arg1, arg2); end

  def set_values(arg, arg1, arg2); end

  def shared?(); end

  def size(); end

  def slice(*arg); end

  def transfer(); end

  def valid?(); end

  def values(*arg); end

  def write(*arg); end

  def xor!(arg); end

  def |(arg); end

  def ~(); end
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
  EXTERNAL = ::T.let(nil, ::T.untyped)
  HOST_ENDIAN = ::T.let(nil, ::T.untyped)
  INTERNAL = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAPPED = ::T.let(nil, ::T.untyped)
  NETWORK_ENDIAN = ::T.let(nil, ::T.untyped)
  PAGE_SIZE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  SHARED = ::T.let(nil, ::T.untyped)
end

class IO::Buffer::AccessError
end

class IO::Buffer::AccessError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::LockedError
end

class IO::Buffer::LockedError
end

class IO::Buffer::MaskError
end

class IO::Buffer::MaskError
end

class IO::Buffer
  def self.for(arg); end

  def self.map(*arg); end

  def self.size_of(arg); end

  def self.string(arg); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO::TimeoutError
end

class IO::TimeoutError
end

class IO
  def self.new(*arg); end
end

class IPAddr
  def ==(other); end

  def begin_addr(); end

  def end_addr(); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def netmask(); end

  def zone_id(); end

  def zone_id=(zid); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  def ceildiv(other); end

  def to_bn(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  def self.try_convert(arg); end
end

class JSON::Ext::Generator::State
  def escape_slash(); end

  def escape_slash=(escape_slash); end

  def escape_slash?(); end

  def script_safe(); end

  def script_safe=(script_safe); end

  def script_safe?(); end

  def strict(); end

  def strict=(strict); end

  def strict?(); end
end

class JSON::Ext::Generator::State
  def self.from_state(arg); end
end

class JSON::Ext::Parser
  def initialize(*arg); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JSON
  def self.create_fast_state(); end

  def self.create_pretty_state(); end
end

module Kernel
  def pretty_inspect(); end
end

module Kernel
  def self.at_exit(); end

  def self.exit(*arg); end

  def self.no_warning_require(arg); end
end

class KeyError
  include ::DidYouMean::Correctable
end

class LoadError
  include ::DidYouMean::Correctable
end

class Logger
  def debug!(); end

  def error!(); end

  def fatal!(); end

  def info!(); end

  def warn!(); end

  def with_level(severity); end
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  DatetimeFormat = ::T.let(nil, ::T.untyped)
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Logger::Severity
  def self.coerce(severity); end
end

class MatchData
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def match(arg); end

  def match_length(arg); end
end

class Maybe::Absent
  extend ::T::Private::Final::NoInherit
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Maybe::Present
  extend ::T::Private::Final::NoInherit
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Maybe
  extend ::T::Private::Abstract::Hooks
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Minitest
  VERSION = ::T.let(nil, ::T.untyped)
end

class Minitest::Assertion
  RE = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class Minitest::BacktraceFilter
  MT_RE = ::T.let(nil, ::T.untyped)
end

module Minitest::Reportable
  BASE_DIR = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Spec
  TYPES = ::T.let(nil, ::T.untyped)
end

module Minitest::Spec::DSL
  TYPES = ::T.let(nil, ::T.untyped)
end

class Minitest::Test
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  SETUP_METHODS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

class Minitest::UnexpectedError
  BASE_RE = ::T.let(nil, ::T.untyped)
end

class Module
  def deprecate(*method_names, deprecator:, **options); end

  def set_temporary_name(arg); end

  def undefined_instance_methods(); end
end

Module::DelegationError = ActiveSupport::DelegationError

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(arg, arg1); end
end

module MonitorMixin
  def initialize(*arg, **arg1, &arg2); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

class NameError
  include ::ErrorHighlight::CoreExt
  include ::DidYouMean::Correctable
end

class NilClass
  def =~(arg); end

  def to_d(); end
end

class NoMatchingPatternKeyError
  include ::DidYouMean::Correctable
  def key(); end

  def matchee(); end
end

class NoMatchingPatternKeyError
end

class Numeric
  def zettabyte(); end

  def zettabytes(); end
  ZETTABYTE = ::T.let(nil, ::T.untyped)
end

class Object
  include ::PP::ObjectMixin
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::ActiveSupport::Dependencies::RequireDependency
  def html_safe?(); end

  def presence_in(another_object); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  def delete(arg); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(arg); end

  def abs(); end

  def get_flags(arg); end

  def mod_sqrt(arg); end

  def negative?(); end

  def set_flags(arg); end
  CONSTTIME = ::T.let(nil, ::T.untyped)
end

module OpenSSL::Buffering
  def getbyte(); end
end

class OpenSSL::Buffering::Buffer
  def <<(string); end

  def concat(string); end

  def initialize(); end
  BINARY = ::T.let(nil, ::T.untyped)
end

class OpenSSL::Buffering::Buffer
end

class OpenSSL::Cipher
  def ccm_data_len=(ccm_data_len); end
end

class OpenSSL::HMAC
  def ==(other); end
end

module OpenSSL::Marshal
  def _dump(_level); end
end

module OpenSSL::Marshal::ClassMethods
  def _load(string); end
end

module OpenSSL::Marshal::ClassMethods
end

module OpenSSL::Marshal
  def self.included(base); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::DH
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::DH
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

class OpenSSL::PKey::DSA
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::DSA
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

class OpenSSL::PKey::EC
  include ::OpenSSL::Marshal
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def add(arg); end

  def to_octet_string(arg); end
end

class OpenSSL::PKey::EC
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::PKey::PKey
  def compare?(arg); end

  def decrypt(*arg); end

  def derive(*arg); end

  def encrypt(*arg); end

  def oid(); end

  def private_to_der(*arg); end

  def private_to_pem(*arg); end

  def public_to_der(); end

  def public_to_pem(); end

  def raw_private_key(); end

  def raw_public_key(); end

  def sign_raw(*arg); end

  def to_text(); end

  def verify_raw(*arg); end

  def verify_recover(*arg); end
end

class OpenSSL::PKey::RSA
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::RSA
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

module OpenSSL::PKey
  def self.generate_key(*arg); end

  def self.generate_parameters(*arg); end

  def self.new_raw_private_key(arg, arg1); end

  def self.new_raw_public_key(arg, arg1); end
end

class OpenSSL::Provider
  def name(); end

  def unload(); end
end

class OpenSSL::Provider::ProviderError
end

class OpenSSL::Provider::ProviderError
end

class OpenSSL::Provider
  def self.load(arg); end

  def self.provider_names(); end
end

module OpenSSL::SSL
  OP_ALLOW_CLIENT_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CLEANSE_PLAINTEXT = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_DISABLE_TLSEXT_CA_NAMES = ::T.let(nil, ::T.untyped)
  OP_ENABLE_KTLS = ::T.let(nil, ::T.untyped)
  OP_ENABLE_MIDDLEBOX_COMPAT = ::T.let(nil, ::T.untyped)
  OP_IGNORE_UNEXPECTED_EOF = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ANTI_REPLAY = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_PRIORITIZE_CHACHA = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def ciphersuites=(ciphersuites); end

  def enable_fallback_scsv(); end

  def keylog_cb(); end

  def keylog_cb=(keylog_cb); end

  def max_version=(version); end

  def min_version=(version); end

  def tmp_dh=(tmp_dh); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def export_keying_material(*arg); end

  def finished_message(); end

  def peer_finished_message(); end

  def tmp_key(); end
end

class OpenSSL::SSL::SSLSocket
  def self.open(remote_host, remote_port, local_host=T.unsafe(nil), local_port=T.unsafe(nil), context: T.unsafe(nil)); end
end

module OpenSSL::SSL::SocketForwarder
  def fileno(); end
end

module OpenSSL::Timestamp
end

class OpenSSL::Timestamp::Factory
  def additional_certs(); end

  def additional_certs=(additional_certs); end

  def allowed_digests(); end

  def allowed_digests=(allowed_digests); end

  def create_timestamp(arg, arg1, arg2); end

  def default_policy_id(); end

  def default_policy_id=(default_policy_id); end

  def gen_time(); end

  def gen_time=(gen_time); end

  def serial_number(); end

  def serial_number=(serial_number); end
end

class OpenSSL::Timestamp::Factory
end

class OpenSSL::Timestamp::Request
  def algorithm(); end

  def algorithm=(algorithm); end

  def cert_requested=(cert_requested); end

  def cert_requested?(); end

  def initialize(*arg); end

  def message_imprint(); end

  def message_imprint=(message_imprint); end

  def nonce(); end

  def nonce=(nonce); end

  def policy_id(); end

  def policy_id=(policy_id); end

  def to_der(); end

  def version(); end

  def version=(version); end
end

class OpenSSL::Timestamp::Request
end

class OpenSSL::Timestamp::Response
  def failure_info(); end

  def initialize(arg); end

  def status(); end

  def status_text(); end

  def to_der(); end

  def token(); end

  def token_info(); end

  def tsa_certificate(); end

  def verify(*arg); end
  GRANTED = ::T.let(nil, ::T.untyped)
  GRANTED_WITH_MODS = ::T.let(nil, ::T.untyped)
  REJECTION = ::T.let(nil, ::T.untyped)
  REVOCATION_NOTIFICATION = ::T.let(nil, ::T.untyped)
  REVOCATION_WARNING = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class OpenSSL::Timestamp::Response
end

class OpenSSL::Timestamp::TimestampError
end

class OpenSSL::Timestamp::TimestampError
end

class OpenSSL::Timestamp::TokenInfo
  def algorithm(); end

  def gen_time(); end

  def initialize(arg); end

  def message_imprint(); end

  def nonce(); end

  def ordering(); end

  def policy_id(); end

  def serial_number(); end

  def to_der(); end

  def version(); end
end

class OpenSSL::Timestamp::TokenInfo
end

module OpenSSL::Timestamp
end

module OpenSSL::X509
  V_ERR_CA_KEY_TOO_SMALL = ::T.let(nil, ::T.untyped)
  V_ERR_CA_MD_TOO_WEAK = ::T.let(nil, ::T.untyped)
  V_ERR_CRL_PATH_VALIDATION_ERROR = ::T.let(nil, ::T.untyped)
  V_ERR_DANE_NO_MATCH = ::T.let(nil, ::T.untyped)
  V_ERR_DIFFERENT_CRL_SCOPE = ::T.let(nil, ::T.untyped)
  V_ERR_EE_KEY_TOO_SMALL = ::T.let(nil, ::T.untyped)
  V_ERR_EMAIL_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_EXCLUDED_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_HOSTNAME_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_CALL = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_NON_CA = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_POLICY_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_IP_ADDRESS_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_KEYUSAGE_NO_CRL_SIGN = ::T.let(nil, ::T.untyped)
  V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE = ::T.let(nil, ::T.untyped)
  V_ERR_NO_EXPLICIT_POLICY = ::T.let(nil, ::T.untyped)
  V_ERR_NO_VALID_SCTS = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_CERT_UNKNOWN = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_VERIFY_FAILED = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_VERIFY_NEEDED = ::T.let(nil, ::T.untyped)
  V_ERR_PATH_LOOP = ::T.let(nil, ::T.untyped)
  V_ERR_PERMITTED_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_PATH_LENGTH_EXCEEDED = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_SUBJECT_NAME_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_STORE_LOOKUP = ::T.let(nil, ::T.untyped)
  V_ERR_SUBTREE_MINMAX = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256 = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_ALGORITHM = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_CURVE = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_VERSION = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_LOS_NOT_ALLOWED = ::T.let(nil, ::T.untyped)
  V_ERR_UNABLE_TO_GET_CRL_ISSUER = ::T.let(nil, ::T.untyped)
  V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_UNHANDLED_CRITICAL_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_UNNESTED_RESOURCE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSPECIFIED = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_CONSTRAINT_TYPE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_EXTENSION_FEATURE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_NAME_SYNTAX = ::T.let(nil, ::T.untyped)
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_PARTIAL_CHAIN = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_128_LOS = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_128_LOS_ONLY = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_192_LOS = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
  V_FLAG_USE_CHECK_TIME = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  include ::OpenSSL::Marshal
  def ==(other); end
end

class OpenSSL::X509::Attribute
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::CRL
  include ::OpenSSL::Marshal
  include ::OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def ==(other); end
end

class OpenSSL::X509::CRL
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Certificate
  include ::OpenSSL::Marshal
  include ::OpenSSL::X509::Extension::SubjectKeyIdentifier
  include ::OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::CRLDistributionPoints
  include ::OpenSSL::X509::Extension::AuthorityInfoAccess
  include ::OpenSSL::X509::Extension::Helpers
end

class OpenSSL::X509::Certificate
  extend ::OpenSSL::Marshal::ClassMethods
  def self.load(arg); end

  def self.load_file(path); end
end

class OpenSSL::X509::Extension
  include ::OpenSSL::Marshal
  def ==(other); end

  def value_der(); end
end

module OpenSSL::X509::Extension::AuthorityInfoAccess
  include ::OpenSSL::X509::Extension::Helpers
  def ca_issuer_uris(); end

  def ocsp_uris(); end
end

module OpenSSL::X509::Extension::AuthorityInfoAccess
end

module OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def authority_key_identifier(); end
end

module OpenSSL::X509::Extension::AuthorityKeyIdentifier
end

module OpenSSL::X509::Extension::CRLDistributionPoints
  include ::OpenSSL::X509::Extension::Helpers
  def crl_uris(); end
end

module OpenSSL::X509::Extension::CRLDistributionPoints
end

module OpenSSL::X509::Extension::Helpers
  def find_extension(oid); end
end

module OpenSSL::X509::Extension::Helpers
end

module OpenSSL::X509::Extension::SubjectKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def subject_key_identifier(); end
end

module OpenSSL::X509::Extension::SubjectKeyIdentifier
end

class OpenSSL::X509::Extension
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Name
  include ::OpenSSL::Marshal
  def to_utf8(); end
end

class OpenSSL::X509::Name
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Request
  include ::OpenSSL::Marshal
  def ==(other); end
end

class OpenSSL::X509::Request
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

class OpenStruct
  def __id__!(); end

  def __send__!(*arg); end

  def class!(); end

  def clone!(freeze: T.unsafe(nil)); end

  def define_singleton_method!(*arg); end

  def delete_field!(name, &block); end

  def dig!(name, *names); end

  def display!(*arg); end

  def dup!(); end

  def each_pair!(); end

  def encode_with(coder); end

  def encode_with!(coder); end

  def enum_for!(*arg); end

  def extend!(mod, *args); end

  def freeze!(); end

  def gem!(dep, *reqs); end

  def hash!(); end

  def init_with(coder); end

  def init_with!(coder); end

  def inspect!(); end

  def instance_eval!(*arg); end

  def instance_exec!(*arg); end

  def instance_variable_get!(arg); end

  def instance_variable_set!(arg, arg1); end

  def instance_variables!(); end

  def itself!(); end

  def marshal_dump!(); end

  def method!(arg); end

  def methods!(*arg); end

  def object_id!(); end

  def private_methods!(*arg); end

  def protected_methods!(*arg); end

  def public_method!(arg); end

  def public_methods!(*arg); end

  def public_send!(*arg); end

  def remove_instance_variable!(arg); end

  def send!(*arg); end

  def singleton_class!(); end

  def singleton_method!(arg); end

  def singleton_methods!(*arg); end

  def tap!(); end

  def then!(); end

  def to_enum!(*arg); end

  def to_h!(&block); end

  def to_s!(); end

  def yield_self!(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class OptionParser
  def additional_message(typ, opt); end

  def raise_unknown(); end

  def raise_unknown=(raise_unknown); end

  def require_exact(); end

  def require_exact=(require_exact); end
  Version = ::T.let(nil, ::T.untyped)
end

class OptionParser::List
  def get_candidates(id); end
end

class OptionParser::ParseError
  def additional(); end

  def additional=(additional); end
end

class OptionParser::Switch
  def pretty_print_contents(q); end
end

class OptionParser::Switch::NoArgument
  def pretty_head(); end
end

class OptionParser::Switch::OptionalArgument
  def pretty_head(); end
end

class OptionParser::Switch::PlacedArgument
  def pretty_head(); end
end

class OptionParser::Switch::RequiredArgument
  def pretty_head(); end
end

class PP
  VERSION = ::T.let(nil, ::T.untyped)
end

class PP
  def self.width_for(out); end
end

class Pathname
  def lutime(arg, arg1); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Polyfill
  VERSION = ::T.let(nil, ::T.untyped)
end

class PrettyPrint
  VERSION = ::T.let(nil, ::T.untyped)
end

class Proc
  def <<(arg); end

  def >>(arg); end

  def clone(); end
end

module Process
  CLOCK_TAI = ::T.let(nil, ::T.untyped)
end

class Process::Status
  def self.wait(*arg); end
end

class Process::Tms
  def self.keyword_init?(); end
end

module Process
  extend ::ConnectionPool::ForkTracker
  extend ::ActiveSupport::ForkTracker::CoreExt
  def self.exit(*arg); end
end

module Psych
  LOADER_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::AliasesNotEnabled
  def initialize(); end
end

class Psych::AliasesNotEnabled
end

class Psych::AnchorNotDefined
  def initialize(anchor_name); end
end

class Psych::AnchorNotDefined
end

class Psych::ScalarScanner
  INTEGER_LEGACY = ::T.let(nil, ::T.untyped)
  INTEGER_STRICT = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::RestrictedYAMLTree
  def visit_Symbol(sym); end
  DEFAULT_PERMITTED_CLASSES = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::RestrictedYAMLTree
end

class Psych::Visitors::Visitor
  def self.dispatch_cache(); end
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.config(); end

  def self.domain_types(); end

  def self.domain_types=(value); end

  def self.dump_tags(); end

  def self.dump_tags=(value); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(value); end

  def self.remove_type(type_tag); end

  def self.safe_dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.unsafe_load(yaml, filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil)); end

  def self.unsafe_load_file(filename, **kwargs); end
end

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  IGNORE_REGEX = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Bisect::Channel
  MARSHAL_DUMP_ENCODING = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ConfigurationOptions
  OPTIONS_ORDER = ::T.let(nil, ::T.untyped)
  UNFORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

RSpec::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
  include ::RSpec::Matchers
  INSTANCE_VARIABLE_TO_IGNORE = ::T.let(nil, ::T.untyped)
end

RSpec::Core::ExclusionRules = RSpec::Core::FilterRules

class RSpec::Core::FilterRules
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::ConsoleCodes
  VT100_CODES = ::T.let(nil, ::T.untyped)
  VT100_CODE_VALUES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter
  DEPRECATION_STREAM_NOTICE = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_CONFIG_NOTICE = ::T.let(nil, ::T.untyped)
  TOO_MANY_WARNINGS_NOTICE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  TOO_MANY_USES_LIMIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::ExceptionPresenter
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::Helpers
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  SUB_SECOND_PRECISION = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::HtmlPrinter
  include ::ERB::Escape
  include ::ActiveSupport::CoreExt::ERBUtilPrivate
  include ::ActiveSupport::CoreExt::ERBUtil
  GLOBAL_SCRIPTS = ::T.let(nil, ::T.untyped)
  GLOBAL_STYLES = ::T.let(nil, ::T.untyped)
  HTML_HEADER = ::T.let(nil, ::T.untyped)
  REPORT_HEADER = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  RESET_CODE = ::T.let(nil, ::T.untyped)
end

RSpec::Core::Formatters::SyntaxHighlighter::WindowsImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

class RSpec::Core::Hooks::HookCollections
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Ordering::Random
  MAX_32_BIT = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Pending
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Profiler
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Reporter
  RSPEC_NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::ShellEscape
  SHELLS_ALLOWING_UNQUOTED_IDS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class RSpec::Expectations::Configuration
  FALSE_POSITIVE_BEHAVIOURS = ::T.let(nil, ::T.untyped)
end

class RSpec::Expectations::FailureAggregator
  AGGREGATED_FAILURE = ::T.let(nil, ::T.untyped)
end

class RSpec::Expectations::FailureAggregator::AggregatedFailure
  MESSAGE = ::T.let(nil, ::T.untyped)
end

RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

class RSpec::Expectations::MultipleExpectationsNotMetError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
end

module RSpec::Expectations::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers
  BE_PREDICATE_REGEX = ::T.let(nil, ::T.untyped)
  DYNAMIC_MATCHER_REGEX = ::T.let(nil, ::T.untyped)
  HAS_REGEX = ::T.let(nil, ::T.untyped)
end

RSpec::Matchers::AliasedNegatedMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

class RSpec::Matchers::BuiltIn::BaseMatcher
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::BePredicate
  REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Equal
  LITERAL_SINGLETONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Has
  REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::RaiseError
  UndefinedValue = ::T.let(nil, ::T.untyped)
end

RSpec::Matchers::BuiltIn::SpecificValuesChange::MATCH_ANYTHING = BasicObject

RSpec::Matchers::BuiltIn::StartAndEndWith = RSpec::Matchers::BuiltIn::StartOrEndWith

module RSpec::Matchers::DSL::Macros
  RAISE_NOTIFIER = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::MultiMatcherDiff
  DEFAULT_DIFF_LABEL = ::T.let(nil, ::T.untyped)
  DESCRIPTION_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks
  DEFAULT_CALLBACK_INVOCATION_STRATEGY = ::T.let(nil, ::T.untyped)
  IGNORED_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
  ExpectationInvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::Recorder
  include ::T::CompatibilityPatches::RSpecCompatibility::RecorderExtensions
end

class RSpec::Mocks::AnyInstance::StubChain
  EmptyInvocationOrder = ::T.let(nil, ::T.untyped)
  InvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentListMatcher
  MATCH_ALL = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ClassNewMethodReference
  CLASS_NEW = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Matchers::HaveReceived
  ARGS_CONSTRAINTS = ::T.let(nil, ::T.untyped)
  CONSTRAINTS = ::T.let(nil, ::T.untyped)
  COUNT_CONSTRAINTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::MethodDouble
  include ::T::CompatibilityPatches::RSpecCompatibility::MethodDoubleExtensions
  FROZEN_ERROR_MSG = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ObjectReference
  MODULE_NAME_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Proxy
  DEFAULT_MESSAGE_EXPECTATION_OPTS = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::Version
  STRING = ::T.let(nil, ::T.untyped)
end

RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
  DEFAULT_FAILURE_NOTIFIER = ::T.let(nil, ::T.untyped)
  DEFAULT_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  AVOID_RESCUING = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Differ
  def color?(); end

  def diff(actual, expected); end

  def diff_as_object(actual, expected); end

  def diff_as_string(actual, expected); end

  def initialize(opts=T.unsafe(nil)); end
end

class RSpec::Support::Differ
end

class RSpec::Support::EncodedString
  REPLACE = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::MethodSignature
  INFINITY = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Mutex
  NEW_MUTEX_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter
  ELLIPSIS = ::T.let(nil, ::T.untyped)
  INSPECTOR_CLASSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::TimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  OBJECT_ID_FORMAT = ::T.let(nil, ::T.untyped)
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class Ractor::ClosedError
end

class Ractor::ClosedError
end

class Ractor::Error
end

class Ractor::Error
end

class Ractor::IsolationError
end

class Ractor::IsolationError
end

class Ractor::MovedError
end

class Ractor::MovedError
end

class Ractor::MovedObject
  def !(*arg); end

  def !=(*arg); end

  def ==(*arg); end

  def __id__(*arg); end

  def equal?(*arg); end
end

class Ractor::MovedObject
end

class Ractor::RemoteError
  def ractor(); end
end

class Ractor::RemoteError
end

class Ractor::UnsafeError
end

class Ractor::UnsafeError
end

class Ractor
  def self.new(*args, name: T.unsafe(nil), &block); end
end

class Random::Base
  include ::Random::Formatter
  def bytes(arg); end

  def initialize(*arg); end

  def seed(); end
end

class Random::Base
  extend ::Random::Formatter
end

module Random::Formatter
  def uuid_v4(); end

  def uuid_v7(extra_timestamp_bits: T.unsafe(nil)); end
end

class Random
  def self.bytes(arg); end

  def self.seed(); end
end

class Range
  def %(arg); end

  def entries(); end

  def reverse_each(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end
end

class Refinement
  def target(); end
end

class Regexp
  def timeout(); end
end

class Regexp
  def self.linear_time?(*arg); end
end

class RepositoryWarmer
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module ResourceRegistry::Capabilities::CapabilityConfig::ClassMethods
  extend ::T::Private::Abstract::Hooks
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module ResourceRegistry::Capabilities::CapabilityConfig
  extend ::T::Private::Abstract::Hooks
  extend ::T::Private::MixesInClassMethods
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::CapabilityFactory
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::Configuration
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::ContextCreator
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::Dtos::Context
  def self.inherited(s); end
end

class ResourceRegistry::Dtos::Sort
  def self.inherited(s); end
end

class ResourceRegistry::EntityFinder
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::I18nKeysForResource
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::InferResources
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::Initializer
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::OpenapiSpecificationGenerator
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::OverridesLoader
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::Registry
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::Relationship
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.inherited(s); end
end

module ResourceRegistry::RelationshipType
  extend ::T::Private::Abstract::Hooks
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module ResourceRegistry::RelationshipTypeFactory
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::RelationshipTypes::BelongsTo
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::RelationshipTypes::HasMany
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::RelationshipTypes::HasManyThrough
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::RelationshipTypes::HasOne
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module ResourceRegistry::Repositories::Base
  extend ::T::Private::Abstract::Hooks
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module ResourceRegistry::Repositories::ReadResult
  extend ::T::Private::Abstract::Hooks
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::Resource
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.inherited(s); end
end

class ResourceRegistry::ResourceStructBuilder
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::SchemaGenerator
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module ResourceRegistry::Tracer
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::Verb
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.inherited(s); end
end

class ResourceRegistry::Versions::Version
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ResourceRegistry::Versions
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class RubyVM::AbstractSyntaxTree::Node
  def all_tokens(); end

  def node_id(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def script_lines(); end

  def source(); end

  def tokens(); end
end

module RubyVM::AbstractSyntaxTree
  def self.node_id_for_backtrace_location(backtrace_location); end
end

class RubyVM::InstructionSequence
  def script_lines(); end
end

class RubyVM::InstructionSequence
  def self.compile_file_prism(*arg); end

  def self.compile_prism(*arg); end
end

module RubyVM::RJIT
end

module RubyVM::RJIT
  def self.enable(); end

  def self.enabled?(); end
end

module RubyVM::YJIT
  def self.disasm(iseq); end

  def self.exit_locations(); end

  def self.insns_compiled(iseq); end

  def self.simulate_oom!(); end

  def self.trace_exit_locations_enabled?(); end
end

class RubyVM
  def self.keep_script_lines(); end

  def self.keep_script_lines=(keep_script_lines); end
end

module RuntimeGeneric
  include ::Kernel
end

ScanError = StringScanner::Error

class SchemaRegistry::FilterField
  def self.inherited(s); end
end

class SchemaRegistry::GenerateFromStruct
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SchemaRegistry::JsonSchemaMapper
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SchemaRegistry::Property
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.inherited(s); end
end

class SchemaRegistry::PropertyMapper
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SchemaRegistry::RbiWriter
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SchemaRegistry::Registry
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SchemaRegistry::Schema
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.inherited(s); end
end

class SchemaRegistry::SchemaLoader
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SecureRandom
  VERSION = ::T.let(nil, ::T.untyped)
end

class Set
  def ==(other); end

  def ===(o); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Shellwords
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Socket
  AF_ALG = ::T.let(nil, ::T.untyped)
  AF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  AF_CAN = ::T.let(nil, ::T.untyped)
  AF_DECnet = ::T.let(nil, ::T.untyped)
  AF_IB = ::T.let(nil, ::T.untyped)
  AF_KCM = ::T.let(nil, ::T.untyped)
  AF_KEY = ::T.let(nil, ::T.untyped)
  AF_LLC = ::T.let(nil, ::T.untyped)
  AF_MPLS = ::T.let(nil, ::T.untyped)
  AF_NETLINK = ::T.let(nil, ::T.untyped)
  AF_PPPOX = ::T.let(nil, ::T.untyped)
  AF_RDS = ::T.let(nil, ::T.untyped)
  AF_TIPC = ::T.let(nil, ::T.untyped)
  AF_VSOCK = ::T.let(nil, ::T.untyped)
  AF_XDP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  PF_ALG = ::T.let(nil, ::T.untyped)
  PF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  PF_CAN = ::T.let(nil, ::T.untyped)
  PF_DECnet = ::T.let(nil, ::T.untyped)
  PF_IB = ::T.let(nil, ::T.untyped)
  PF_KCM = ::T.let(nil, ::T.untyped)
  PF_LLC = ::T.let(nil, ::T.untyped)
  PF_MPLS = ::T.let(nil, ::T.untyped)
  PF_NETLINK = ::T.let(nil, ::T.untyped)
  PF_PPPOX = ::T.let(nil, ::T.untyped)
  PF_RDS = ::T.let(nil, ::T.untyped)
  PF_TIPC = ::T.let(nil, ::T.untyped)
  PF_VSOCK = ::T.let(nil, ::T.untyped)
  PF_XDP = ::T.let(nil, ::T.untyped)
  SOCK_CLOEXEC = ::T.let(nil, ::T.untyped)
  SOCK_NONBLOCK = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
  SO_INCOMING_CPU = ::T.let(nil, ::T.untyped)
  SO_INCOMING_NAPI_ID = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_ALG = ::T.let(nil, ::T.untyped)
  AF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  AF_CAN = ::T.let(nil, ::T.untyped)
  AF_DECnet = ::T.let(nil, ::T.untyped)
  AF_IB = ::T.let(nil, ::T.untyped)
  AF_KCM = ::T.let(nil, ::T.untyped)
  AF_KEY = ::T.let(nil, ::T.untyped)
  AF_LLC = ::T.let(nil, ::T.untyped)
  AF_MPLS = ::T.let(nil, ::T.untyped)
  AF_NETLINK = ::T.let(nil, ::T.untyped)
  AF_PPPOX = ::T.let(nil, ::T.untyped)
  AF_RDS = ::T.let(nil, ::T.untyped)
  AF_TIPC = ::T.let(nil, ::T.untyped)
  AF_VSOCK = ::T.let(nil, ::T.untyped)
  AF_XDP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  PF_ALG = ::T.let(nil, ::T.untyped)
  PF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  PF_CAN = ::T.let(nil, ::T.untyped)
  PF_DECnet = ::T.let(nil, ::T.untyped)
  PF_IB = ::T.let(nil, ::T.untyped)
  PF_KCM = ::T.let(nil, ::T.untyped)
  PF_LLC = ::T.let(nil, ::T.untyped)
  PF_MPLS = ::T.let(nil, ::T.untyped)
  PF_NETLINK = ::T.let(nil, ::T.untyped)
  PF_PPPOX = ::T.let(nil, ::T.untyped)
  PF_RDS = ::T.let(nil, ::T.untyped)
  PF_TIPC = ::T.let(nil, ::T.untyped)
  PF_VSOCK = ::T.let(nil, ::T.untyped)
  PF_XDP = ::T.let(nil, ::T.untyped)
  SOCK_CLOEXEC = ::T.let(nil, ::T.untyped)
  SOCK_NONBLOCK = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
  SO_INCOMING_CPU = ::T.let(nil, ::T.untyped)
  SO_INCOMING_NAPI_ID = ::T.let(nil, ::T.untyped)
end

class Socket::ResolutionError
  def error_code(); end
end

class String
  def dedup(); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

class String
  def self.new(*arg); end
end

class StringIO
  def pread(*arg); end

  def set_encoding_by_bom(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringIO
  def self.new(*arg); end
end

class StringScanner
  def bol?(); end

  def fixed_anchor?(); end

  def initialize(*arg); end

  def named_captures(); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def filter(*arg); end
end

class Struct
  def self.new(*arg); end
end

class SyntaxError
  def path(); end
end

module SyntaxSuggest
end

class SyntaxSuggest::MiniStringIO
  def initialize(isatty: T.unsafe(nil)); end

  def isatty(); end

  def puts(value=T.unsafe(nil), **arg); end

  def string(); end
end

class SyntaxSuggest::MiniStringIO
end

module SyntaxSuggest
  def self.module_for_detailed_message(); end
end

module TZInfo
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tempfile
  def _close(); end

  def finalizer_obj(); end

  def mode(); end

  def opts(); end

  def unlinked(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tempfile::Closer
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Closer
end

class Tempfile::Remover
  def call(*args); end

  def initialize(path); end
end

class Tempfile::Remover
end

class Thread::Backtrace
  def self.limit(); end
end

class Thread
  def self.ignore_deadlock(); end

  def self.ignore_deadlock=(ignore_deadlock); end

  def self.new(*arg); end
end

class Time
  def deconstruct_keys(arg); end
  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Timeout
  VERSION = ::T.let(nil, ::T.untyped)
end

class Timeout::Error
  def self.handle_timeout(message); end
end

class Timeout::ExitException
  def exception(*arg); end
end

class Timeout::ExitException
end

module Timeout
  def self.ensure_timeout_thread_created(); end
end

class TracePoint
  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.allow_reentry(); end

  def self.new(*events); end
end

module TypeCoerce::Configuration
  extend ::T::Private::Methods::SingletonMethodHooks
end

class TypeCoerce::Converter
  PRIMITIVE_TYPES = ::T.let(nil, ::T.untyped)
end

class TypeError
  include ::ErrorHighlight::CoreExt
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  extend ::Warning
end

class WeakRef
  def initialize(orig); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end
